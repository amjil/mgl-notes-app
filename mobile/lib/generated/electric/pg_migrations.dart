// GENERATED CODE - DO NOT MODIFY BY HAND

// ignore_for_file: always_use_package_imports, depend_on_referenced_packages
// ignore_for_file: prefer_double_quotes

import 'package:electricsql/electricsql.dart';

const kPostgresMigrations = <Migration>[
  Migration(
    statements: [
      'CREATE TABLE folders (\n    id uuid NOT NULL,\n    parent_id uuid,\n    electric_user_id uuid NOT NULL,\n    name text,\n    order_num integer,\n    related_num integer,\n    CONSTRAINT folders_pkey PRIMARY KEY (id)\n)',
      'INSERT INTO "public"."_electric_trigger_settings" ("namespace", "tablename", "flag")\nVALUES (\'public\', \'folders\', 1)\nON CONFLICT DO NOTHING;\n',
      'DROP TRIGGER IF EXISTS update_ensure_public_folders_primarykey ON "public"."folders";',
      '        CREATE OR REPLACE FUNCTION update_ensure_public_folders_primarykey_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          IF OLD."id" IS DISTINCT FROM NEW."id" THEN\n            RAISE EXCEPTION \'Cannot change the value of column id as it belongs to the primary key\';\n          END IF;\n          RETURN NEW;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_ensure_public_folders_primarykey\n          BEFORE UPDATE ON "public"."folders"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_ensure_public_folders_primarykey_function();\n      ',
      'DROP TRIGGER IF EXISTS insert_public_folders_into_oplog ON "public"."folders";',
      '        CREATE OR REPLACE FUNCTION insert_public_folders_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'folders\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'folders\',\n                \'INSERT\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'name\', new."name", \'order_num\', new."order_num", \'parent_id\', new."parent_id", \'related_num\', new."related_num"),\n                NULL,\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER insert_public_folders_into_oplog\n          AFTER INSERT ON "public"."folders"\n            FOR EACH ROW\n              EXECUTE FUNCTION insert_public_folders_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS update_public_folders_into_oplog ON "public"."folders";',
      '        CREATE OR REPLACE FUNCTION update_public_folders_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'folders\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'folders\',\n                \'UPDATE\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'name\', new."name", \'order_num\', new."order_num", \'parent_id\', new."parent_id", \'related_num\', new."related_num"),\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'name\', old."name", \'order_num\', old."order_num", \'parent_id\', old."parent_id", \'related_num\', old."related_num"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_public_folders_into_oplog\n          AFTER UPDATE ON "public"."folders"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_public_folders_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS delete_public_folders_into_oplog ON "public"."folders";',
      '        CREATE OR REPLACE FUNCTION delete_public_folders_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'folders\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'folders\',\n                \'DELETE\',\n                json_strip_nulls(json_build_object(\'id\', old."id")),\n                NULL,\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'name\', old."name", \'order_num\', old."order_num", \'parent_id\', old."parent_id", \'related_num\', old."related_num"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER delete_public_folders_into_oplog\n          AFTER DELETE ON "public"."folders"\n            FOR EACH ROW\n              EXECUTE FUNCTION delete_public_folders_into_oplog_function();\n      ',
    ],
    version: '20240615022233',
  ),
  Migration(
    statements: [
      'CREATE TABLE notes (\n    id uuid NOT NULL,\n    folder_id uuid,\n    electric_user_id uuid NOT NULL,\n    content text,\n    flag smallint NOT NULL,\n    status smallint NOT NULL,\n    created_at timestamp without time zone,\n    updated_at timestamp without time zone,\n    CONSTRAINT notes_pkey PRIMARY KEY (id),\n    CONSTRAINT notes_folder_id_fkey FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE\n)',
      'INSERT INTO "public"."_electric_trigger_settings" ("namespace", "tablename", "flag")\nVALUES (\'public\', \'notes\', 1)\nON CONFLICT DO NOTHING;\n',
      'DROP TRIGGER IF EXISTS update_ensure_public_notes_primarykey ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION update_ensure_public_notes_primarykey_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          IF OLD."id" IS DISTINCT FROM NEW."id" THEN\n            RAISE EXCEPTION \'Cannot change the value of column id as it belongs to the primary key\';\n          END IF;\n          RETURN NEW;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_ensure_public_notes_primarykey\n          BEFORE UPDATE ON "public"."notes"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_ensure_public_notes_primarykey_function();\n      ',
      'DROP TRIGGER IF EXISTS insert_public_notes_into_oplog ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION insert_public_notes_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'notes\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'notes\',\n                \'INSERT\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'content\', new."content", \'created_at\', new."created_at", \'electric_user_id\', new."electric_user_id", \'flag\', new."flag", \'folder_id\', new."folder_id", \'id\', new."id", \'status\', new."status", \'updated_at\', new."updated_at"),\n                NULL,\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER insert_public_notes_into_oplog\n          AFTER INSERT ON "public"."notes"\n            FOR EACH ROW\n              EXECUTE FUNCTION insert_public_notes_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS update_public_notes_into_oplog ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION update_public_notes_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'notes\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'notes\',\n                \'UPDATE\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'content\', new."content", \'created_at\', new."created_at", \'electric_user_id\', new."electric_user_id", \'flag\', new."flag", \'folder_id\', new."folder_id", \'id\', new."id", \'status\', new."status", \'updated_at\', new."updated_at"),\n                jsonb_build_object(\'content\', old."content", \'created_at\', old."created_at", \'electric_user_id\', old."electric_user_id", \'flag\', old."flag", \'folder_id\', old."folder_id", \'id\', old."id", \'status\', old."status", \'updated_at\', old."updated_at"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_public_notes_into_oplog\n          AFTER UPDATE ON "public"."notes"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_public_notes_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS delete_public_notes_into_oplog ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION delete_public_notes_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'notes\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'notes\',\n                \'DELETE\',\n                json_strip_nulls(json_build_object(\'id\', old."id")),\n                NULL,\n                jsonb_build_object(\'content\', old."content", \'created_at\', old."created_at", \'electric_user_id\', old."electric_user_id", \'flag\', old."flag", \'folder_id\', old."folder_id", \'id\', old."id", \'status\', old."status", \'updated_at\', old."updated_at"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER delete_public_notes_into_oplog\n          AFTER DELETE ON "public"."notes"\n            FOR EACH ROW\n              EXECUTE FUNCTION delete_public_notes_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS compensation_insert_public_notes_folder_id_into_oplog ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION compensation_insert_public_notes_folder_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'notes\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'folders\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."folders"\n              WHERE "id" = NEW."folder_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_insert_public_notes_folder_id_into_oplog\n            AFTER INSERT ON "public"."notes"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_insert_public_notes_folder_id_into_oplog_function();\n        ',
      'DROP TRIGGER IF EXISTS compensation_update_public_notes_folder_id_into_oplog ON "public"."notes";',
      '        CREATE OR REPLACE FUNCTION compensation_update_public_notes_folder_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'notes\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'folders\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."folders"\n              WHERE "id" = NEW."folder_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_update_public_notes_folder_id_into_oplog\n            AFTER UPDATE ON "public"."notes"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_update_public_notes_folder_id_into_oplog_function();\n        ',
    ],
    version: '20240615042050',
  ),
  Migration(
    statements: [
      'CREATE TABLE tags (\n    id uuid NOT NULL,\n    electric_user_id uuid NOT NULL,\n    name text,\n    related_num integer,\n    CONSTRAINT tags_pkey PRIMARY KEY (id)\n)',
      'CREATE TABLE note_tags (\n    id uuid NOT NULL,\n    electric_user_id uuid NOT NULL,\n    tag_id uuid,\n    note_id uuid,\n    CONSTRAINT note_tags_pkey PRIMARY KEY (id),\n    CONSTRAINT note_tags_note_id_fkey FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE,\n    CONSTRAINT note_tags_tag_id_fkey FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n)',
      'INSERT INTO "public"."_electric_trigger_settings" ("namespace", "tablename", "flag")\nVALUES (\'public\', \'tags\', 1)\nON CONFLICT DO NOTHING;\n',
      'DROP TRIGGER IF EXISTS update_ensure_public_tags_primarykey ON "public"."tags";',
      '        CREATE OR REPLACE FUNCTION update_ensure_public_tags_primarykey_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          IF OLD."id" IS DISTINCT FROM NEW."id" THEN\n            RAISE EXCEPTION \'Cannot change the value of column id as it belongs to the primary key\';\n          END IF;\n          RETURN NEW;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_ensure_public_tags_primarykey\n          BEFORE UPDATE ON "public"."tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_ensure_public_tags_primarykey_function();\n      ',
      'DROP TRIGGER IF EXISTS insert_public_tags_into_oplog ON "public"."tags";',
      '        CREATE OR REPLACE FUNCTION insert_public_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'tags\',\n                \'INSERT\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'name\', new."name", \'related_num\', new."related_num"),\n                NULL,\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER insert_public_tags_into_oplog\n          AFTER INSERT ON "public"."tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION insert_public_tags_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS update_public_tags_into_oplog ON "public"."tags";',
      '        CREATE OR REPLACE FUNCTION update_public_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'tags\',\n                \'UPDATE\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'name\', new."name", \'related_num\', new."related_num"),\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'name\', old."name", \'related_num\', old."related_num"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_public_tags_into_oplog\n          AFTER UPDATE ON "public"."tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_public_tags_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS delete_public_tags_into_oplog ON "public"."tags";',
      '        CREATE OR REPLACE FUNCTION delete_public_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'tags\',\n                \'DELETE\',\n                json_strip_nulls(json_build_object(\'id\', old."id")),\n                NULL,\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'name\', old."name", \'related_num\', old."related_num"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER delete_public_tags_into_oplog\n          AFTER DELETE ON "public"."tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION delete_public_tags_into_oplog_function();\n      ',
      'INSERT INTO "public"."_electric_trigger_settings" ("namespace", "tablename", "flag")\nVALUES (\'public\', \'note_tags\', 1)\nON CONFLICT DO NOTHING;\n',
      'DROP TRIGGER IF EXISTS update_ensure_public_note_tags_primarykey ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION update_ensure_public_note_tags_primarykey_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          IF OLD."id" IS DISTINCT FROM NEW."id" THEN\n            RAISE EXCEPTION \'Cannot change the value of column id as it belongs to the primary key\';\n          END IF;\n          RETURN NEW;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_ensure_public_note_tags_primarykey\n          BEFORE UPDATE ON "public"."note_tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_ensure_public_note_tags_primarykey_function();\n      ',
      'DROP TRIGGER IF EXISTS insert_public_note_tags_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION insert_public_note_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'note_tags\',\n                \'INSERT\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'note_id\', new."note_id", \'tag_id\', new."tag_id"),\n                NULL,\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER insert_public_note_tags_into_oplog\n          AFTER INSERT ON "public"."note_tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION insert_public_note_tags_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS update_public_note_tags_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION update_public_note_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'note_tags\',\n                \'UPDATE\',\n                json_strip_nulls(json_build_object(\'id\', new."id")),\n                jsonb_build_object(\'electric_user_id\', new."electric_user_id", \'id\', new."id", \'note_id\', new."note_id", \'tag_id\', new."tag_id"),\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'note_id\', old."note_id", \'tag_id\', old."tag_id"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER update_public_note_tags_into_oplog\n          AFTER UPDATE ON "public"."note_tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION update_public_note_tags_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS delete_public_note_tags_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION delete_public_note_tags_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n          BEGIN\n            -- Get the flag value from _electric_trigger_settings\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            IF flag_value = 1 THEN\n              -- Insert into _electric_oplog\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              VALUES (\n                \'public\',\n                \'note_tags\',\n                \'DELETE\',\n                json_strip_nulls(json_build_object(\'id\', old."id")),\n                NULL,\n                jsonb_build_object(\'electric_user_id\', old."electric_user_id", \'id\', old."id", \'note_id\', old."note_id", \'tag_id\', old."tag_id"),\n                NULL\n              );\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n      ',
      '        CREATE TRIGGER delete_public_note_tags_into_oplog\n          AFTER DELETE ON "public"."note_tags"\n            FOR EACH ROW\n              EXECUTE FUNCTION delete_public_note_tags_into_oplog_function();\n      ',
      'DROP TRIGGER IF EXISTS compensation_insert_public_note_tags_note_id_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION compensation_insert_public_note_tags_note_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'notes\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."notes"\n              WHERE "id" = NEW."note_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_insert_public_note_tags_note_id_into_oplog\n            AFTER INSERT ON "public"."note_tags"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_insert_public_note_tags_note_id_into_oplog_function();\n        ',
      'DROP TRIGGER IF EXISTS compensation_update_public_note_tags_note_id_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION compensation_update_public_note_tags_note_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'notes\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."notes"\n              WHERE "id" = NEW."note_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_update_public_note_tags_note_id_into_oplog\n            AFTER UPDATE ON "public"."note_tags"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_update_public_note_tags_note_id_into_oplog_function();\n        ',
      'DROP TRIGGER IF EXISTS compensation_insert_public_note_tags_tag_id_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION compensation_insert_public_note_tags_tag_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'tags\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."tags"\n              WHERE "id" = NEW."tag_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_insert_public_note_tags_tag_id_into_oplog\n            AFTER INSERT ON "public"."note_tags"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_insert_public_note_tags_tag_id_into_oplog_function();\n        ',
      'DROP TRIGGER IF EXISTS compensation_update_public_note_tags_tag_id_into_oplog ON "public"."note_tags";',
      '        CREATE OR REPLACE FUNCTION compensation_update_public_note_tags_tag_id_into_oplog_function()\n        RETURNS TRIGGER AS \$\$\n        BEGIN\n          DECLARE\n            flag_value INTEGER;\n            meta_value INTEGER;\n          BEGIN\n            SELECT flag INTO flag_value FROM "public"._electric_trigger_settings WHERE namespace = \'public\' AND tablename = \'note_tags\';\n    \n            SELECT value INTO meta_value FROM "public"._electric_meta WHERE key = \'compensations\';\n    \n            IF flag_value = 1 AND meta_value = 1 THEN\n              INSERT INTO "public"._electric_oplog (namespace, tablename, optype, "primaryKey", "newRow", "oldRow", timestamp)\n              SELECT\n                \'public\',\n                \'tags\',\n                \'COMPENSATION\',\n                json_strip_nulls(json_strip_nulls(json_build_object(\'id\', "id"))),\n                jsonb_build_object(\'id\', "id"),\n                NULL,\n                NULL\n              FROM "public"."tags"\n              WHERE "id" = NEW."tag_id";\n            END IF;\n    \n            RETURN NEW;\n          END;\n        END;\n        \$\$ LANGUAGE plpgsql;\n        ',
      '          CREATE TRIGGER compensation_update_public_note_tags_tag_id_into_oplog\n            AFTER UPDATE ON "public"."note_tags"\n              FOR EACH ROW\n                EXECUTE FUNCTION compensation_update_public_note_tags_tag_id_into_oplog_function();\n        ',
    ],
    version: '20240615042239',
  ),
];
