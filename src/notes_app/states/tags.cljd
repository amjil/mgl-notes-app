(ns notes-app.states.tags
  (:require
   [notes-app.services.database :as db]
   [notes-app.states.global :as gs]))

;; ==================== State definition ====================
;; Tags state management for handling tag operations and UI state

(def tags-state
  (atom {:tags []
         :current-tag nil
         :loading false
         :error nil
         :selected-tags #{}
         :tag-suggestions []}))

(declare get-tags)

;; ==================== Common utility functions ====================

;; Handle error in tag operations
(defn handle-error [error]
  (swap! tags-state assoc :error (str error) :loading false)
  (dart:core/print (str "Tags operation error: " error)))

;; Handle success in tag operations
(defn handle-success [data]
  (swap! tags-state assoc 
         :tags data 
         :loading false 
         :error nil))

;; ==================== Tag CRUD operations ====================

;; Load all tags
(defn load-tags []
  (swap! tags-state assoc :loading true :error nil)
  (try
    (let [tags (await (db/get-all-tags))]
      (handle-success tags))
    (catch Exception e
      (handle-error e))))

;; Create a new tag
(defn create-tag [tag-data]
  (swap! tags-state assoc :loading true :error nil)
  (try
    (let [tag (await (db/create-tag tag-data))
          current-tags (:tags @tags-state)]
      (swap! tags-state assoc 
             :tags (conj current-tags tag)
             :current-tag tag
             :loading false
             :error nil)
      (get-tags)
      tag)
    (catch Exception e
      (handle-error e))))

;; Update an existing tag
(defn update-tag [tag]
  (swap! tags-state assoc :loading true :error nil)
  (try
    (await (db/update-tag tag))
    (let [current-tags (:tags @tags-state)
          updated-tags (map (fn [t]
                             (if (= (.-id t) (.-id tag))
                               tag
                               t))
                           current-tags)]
      (swap! tags-state assoc 
             :tags updated-tags
             :current-tag tag
             :loading false
             :error nil))
    (catch Exception e
      (handle-error e))))

;; Delete a tag
(defn delete-tag [id]
  (swap! tags-state assoc :loading true :error nil)
  (try
    (await (db/delete-tag id))
    (let [current-tags (:tags @tags-state)
          filtered-tags (filter (fn [t]
                                 (not= (.-id t) id))
                               current-tags)]
      (swap! tags-state assoc 
             :tags filtered-tags
             :current-tag nil
             :loading false
             :error nil))
    (catch Exception e
      (handle-error e))))

;; ==================== Tag search and filtering ====================

;; Search tags by query
(defn search-tags [query]
  (swap! tags-state assoc :loading true :error nil)
  (try
    (let [tags (await (db/search-tags query))]
      (swap! tags-state assoc :tag-suggestions tags :loading false :error nil))
    (catch Exception e
      (handle-error e))))

;; Get popular tags
(defn get-popular-tags [limit]
  (swap! tags-state assoc :loading true :error nil)
  (try
    (let [tags (await (db/get-popular-tags limit))]
      (handle-success tags))
    (catch Exception e
      (handle-error e))))

;; ==================== Tag-note relationship operations ====================

;; Get tags by note (if supported by database service)
(defn get-tags-by-note [note-id]
  (swap! tags-state assoc :loading true :error nil)
  (try
    ;; Note: This would need to be implemented in database service
    ;; (let [tags (await (db/get-tags-by-note note-id))]
    ;;   (handle-success tags))
    (swap! tags-state assoc :loading false :error nil)
    (catch Exception e
      (handle-error e))))

;; Add tag to note (if supported by database service)
(defn add-tag-to-note [note-id tag-id]
  (swap! tags-state assoc :loading true :error nil)
  (try
    ;; Note: This would need to be implemented in database service
    ;; (await (db/add-tag-to-note note-id tag-id))
    (swap! tags-state assoc :loading false :error nil)
    (catch Exception e
      (handle-error e))))

;; Remove tag from note (if supported by database service)
(defn remove-tag-from-note [note-id tag-id]
  (swap! tags-state assoc :loading true :error nil)
  (try
    ;; Note: This would need to be implemented in database service
    ;; (await (db/remove-tag-from-note note-id tag-id))
    (swap! tags-state assoc :loading false :error nil)
    (catch Exception e
      (handle-error e))))

;; ==================== Current tag management ====================

;; Set the current tag
(defn set-current-tag [tag]
  (swap! tags-state assoc :current-tag tag))

;; Clear the current tag
(defn clear-current-tag []
  (swap! tags-state assoc :current-tag nil))

;; Get the current tag
(defn get-current-tag []
  (:current-tag @tags-state))

;; ==================== State getters ====================

;; Get all tags
(defn get-tags []
  (:tags @tags-state))

;; Get tag suggestions
(defn get-tag-suggestions []
  (:tag-suggestions @tags-state))

;; Clear tag suggestions
(defn clear-tag-suggestions []
  (swap! tags-state assoc :tag-suggestions []))

;; Get loading state
(defn get-loading []
  (:loading @tags-state))

;; Get error state
(defn get-error []
  (:error @tags-state))

;; ==================== Tag selection management ====================

;; Select a tag
(defn select-tag [tag-id]
  (swap! tags-state update :selected-tags conj tag-id))

;; Deselect a tag
(defn deselect-tag [tag-id]
  (swap! tags-state update :selected-tags disj tag-id))

;; Clear all selected tags
(defn clear-selected-tags []
  (swap! tags-state assoc :selected-tags #{}))

;; Get selected tags
(defn get-selected-tags []
  (:selected-tags @tags-state))

;; Check if a tag is selected
(defn is-tag-selected? [tag-id]
  (contains? (:selected-tags @tags-state) tag-id)) 