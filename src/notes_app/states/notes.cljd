(ns notes-app.states.notes
  (:require
   [notes-app.states.database :as db]
   [clojure.string :as str]))

;; Notes State Management
;; Responsible for managing note-related business logic and composite operations

;; ===== Notes State Operations =====

;; Load all notes
(defn load-notes! []
  (let [db-service (db/get-database-service)]
    (when db-service
      (swap! db/data-state assoc :loading true)
      (-> (.getAllNotes db-service)
          (.then (fn [notes]
                   (swap! db/data-state assoc 
                          :notes notes
                          :loading false
                          :last-updated (Date.now))))
          (.catchError (fn [error]
                         (swap! db/data-state assoc 
                                :error (str error)
                                :loading false)))))))

;; Load paginated notes
(defn load-notes-paginated! [page page-size]
  (let [db-service (db/get-database-service)]
    (when db-service
      (swap! db/data-state assoc :loading-more true)
      (-> (.getNotesPaginated db-service page page-size)
          (.then (fn [notes]
                   (swap! db/data-state assoc 
                          :notes notes
                          :loading-more false
                          :current-page page
                          :last-updated (DateTime/now))))
          (.catchError (fn [error]
                         (swap! db/data-state assoc 
                                :error (str error)
                                :loading-more false)))))))

;; Create note
(defn create-note! [title & [id]]
  (let [db-service (db/get-database-service)]
    (when db-service
      (-> (.createNoteSimple db-service title id)
          (.then (fn [note-id]
                   ;; Reload notes list
                   (load-notes!)
                   {:success true :note-id note-id}))
          (.catchError (fn [error]
                         {:success false :error (str error)}))))))

;; Update note title
(defn update-note-title! [id title]
  (let [db-service (db/get-database-service)]
    (when db-service
      (-> (.updateNoteTitle db-service id title)
          (.then (fn [success]
                   (when success
                     ;; Update local state
                     (swap! db/data-state update :notes
                            (fn [notes]
                              (map (fn [note]
                                     (if (= (:id note) id)
                                       (assoc note :title title)
                                       note))
                                   notes))))
                   {:success success}))
          (.catchError (fn [error]
                         {:success false :error (str error)}))))))

;; Delete note
(defn delete-note! [id]
  (let [db-service (db/get-database-service)]
    (when db-service
      (-> (.deleteNote db-service id)
          (.then (fn [success]
                   (when success
                     ;; Remove from local state
                     (swap! db/data-state update :notes
                            (fn [notes]
                              (filter #(not= (:id %) id) notes))))
                   {:success success}))
          (.catchError (fn [error]
                         {:success false :error (str error)}))))))

;; Get note details
(defn get-note-detail! [id]
  (let [db-service (db/get-database-service)]
    (when db-service
      (-> (.getNoteById db-service id)
          (.then (fn [note]
                   (when note
                     (swap! db/data-state assoc :current-note note))
                   note))
          (.catchError (fn [error]
                         (swap! db/data-state assoc :error (str error))
                         nil))))))

;; Set current note
(defn set-current-note! [note]
  (swap! db/data-state assoc :current-note note))

;; Clear current note
(defn clear-current-note! []
  (swap! db/data-state assoc :current-note nil))

;; ===== Notes State Queries =====

;; Get all notes
(defn get-notes []
  (:notes @db/data-state))

;; Get current note
(defn get-current-note []
  (:current-note @db/data-state))

;; Get note by ID
(defn get-note-by-id [id]
  (first (filter #(= (:id %) id) (:notes @db/data-state))))

;; Check if loading
(defn is-loading? []
  (:loading @db/data-state))

;; Check if loading more
(defn is-loading-more? []
  (:loading-more @db/data-state))

;; Get error message
(defn get-error []
  (:error @db/data-state))

;; Get last updated time
(defn get-last-updated []
  (:last-updated @db/data-state))

;; ===== Notes Statistics =====

;; Get notes count
(defn get-notes-count []
  (count (:notes @db/data-state)))

;; Get notes statistics
(defn get-notes-stats []
  (let [notes (:notes @db/data-state)]
    {:total-count (count notes)
     :with-tags (count (filter #(not-empty (:tags %)) notes))
     :recent-notes (count (filter #(> (- (Date.now) (:updated-at %)) (* 24 60 60 1000)) notes))}))

;; ===== Notes Search =====

;; Search notes
(defn search-notes! [query]
  (let [db-service (db/get-database-service)]
    (when db-service
      (swap! db/search-state assoc :searching true :query query)
      (-> (.searchNotes db-service query)
          (.then (fn [results]
                   (swap! db/search-state assoc 
                          :results results
                          :searching false
                          :last-search (Date.now))))
          (.catchError (fn [error]
                         (swap! db/search-state assoc 
                                :error (str error)
                                :searching false)))))))

;; Get search results
(defn get-search-results []
  (:results @db/search-state))

;; Check if searching
(defn is-searching? []
  (:searching @db/search-state))

;; Get search query
(defn get-search-query []
  (:query @db/search-state))