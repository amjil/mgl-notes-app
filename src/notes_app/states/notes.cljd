(ns notes-app.states.notes
  (:require
   ["package:uuid/uuid.dart" :as uuid]
   [clojure.string :as str]
   [notes-app.services.db :as db]
   [notes-app.utils.state-helpers :as helpers]
   [notes-app.utils.string :as string-utils]))

;; Notes State Management
;; Responsible for managing notes-related states, including notes list, current note, etc.

;; Notes State
(def notes-state
  (atom
   (helpers/create-base-state
    {:notes []
     :current-note nil
     ;; Note navigation history stack for back navigation
     :note-history []
     ;; Filtering
     :filter-tag-id nil
     :filter-tag-name nil
     :filter-date nil})))

(def ^uuid/Uuid uuid-instance (uuid/Uuid.))

;; ===== Notes State Operations =====

;; Load notes paginated
(defn load-notes-paginated! [ctx page & [page-size]]
  (let [limit (or page-size 20)]
    (helpers/with-loading-state! ctx notes-state
      (-> (cond
            (not (nil? (:filter-tag-id @notes-state)))
            (db/get-notes-by-tag (:filter-tag-id @notes-state) page limit)

            (not (nil? (:filter-date @notes-state)))
            (db/get-notes-by-date (:filter-date @notes-state) page limit)

            :else
            (db/get-notes-paginated page limit))

          (.then (fn [notes]
                   (helpers/handle-pagination-result! notes-state page notes limit)))))))

;; Load all notes
(defn load-all-notes! [ctx]
  (helpers/with-loading-state! ctx notes-state
    (-> (db/get-all-notes)
        (.then (fn [notes]
                 (swap! notes-state assoc :notes notes :loading false))))))

;; Create note
(defn create-note! [ctx id title]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/create-note id title)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx 0))
                 success)))
    "Тэмдэглэл амжилттай үүслээ"))

;; Create note with content (4 steps)
(defn create-note-with-content! [ctx content & [operation]]
  (let [id (.v4 uuid-instance)]
    (helpers/with-success-toast! ctx notes-state
      (-> (db/create-note-with-content content id)
          (.then (fn [_]
                   (load-notes-paginated! ctx 0)
                   (when operation
                     (operation)))))
      "Тэмдэглэл амжилттай үүслээ")))

;; Update note
(defn update-note! [ctx id title]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/update-note id title)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx (:current-page @notes-state)))
                 success)))
    "Тэмдэглэл амжилттай шинэчлэгдлээ"))

;; Update note with content (4 steps)
(defn update-note-with-content! [ctx id content & [operation]]
  (let [title (string-utils/extract-title-from-content content)]
    (-> (db/update-note-with-content id title content)
        (.then (fn [_]
                 (load-notes-paginated! ctx (:current-page @notes-state))
                 (when operation
                   (operation)))))))

;; Delete note
(defn delete-note! [ctx id]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/soft-delete-note id)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx 0))
                 success)))
    "Тэмдэглэл амжилттай устгагдлаа"))

;; Delete note with blocks (3 steps)
(defn delete-note-with-blocks! [ctx id]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/delete-note-with-blocks id)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx (:current-page @notes-state)))
                 success)))
    "Тэмдэглэл амжилттай устгагдлаа"))

;; Restore deleted note
(defn restore-note! [ctx id]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/restore-note id)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx (:current-page @notes-state)))
                 success)))
    "Тэмдэглэл амжилттай сэргээгдлээ"))

;; Hard delete note (permanently remove)
(defn hard-delete-note! [ctx id]
  (helpers/with-success-toast! ctx notes-state
    (-> (db/hard-delete-note id)
        (.then (fn [success]
                 (when success
                   (load-notes-paginated! ctx (:current-page @notes-state)))
                 success)))
    "Тэмдэглэл бүрмөсөн устгагдлаа"))

;; Load deleted notes
(defn load-deleted-notes! [ctx page & [page-size]]
  (let [limit (or page-size 20)]
    (helpers/with-loading-state! ctx notes-state
      (-> (db/get-deleted-notes page limit)
          (.then (fn [notes]
                   (helpers/handle-pagination-result! notes-state page notes limit)))))))

;; Get note by id
(defn get-note-by-id! [ctx id]
  (helpers/with-loading-state! ctx notes-state
    (-> (db/get-note-by-id id)
        (.then (fn [note]
                 (swap! notes-state assoc :current-note note :loading false))))))

;; Set current note
(defn set-current-note! [note]
  (swap! notes-state assoc :current-note note))

;; Set current note and save previous note to history
(defn set-current-note-with-history! [note]
  (let [current (:current-note @notes-state)]
    (when (and (not (nil? current)) (not (nil? note)))
      ;; Save current note to history before switching
      (swap! notes-state 
             (fn [state]
               (update state :note-history 
                      (fn [history]
                        (conj (vec history) current))))))
    (swap! notes-state assoc :current-note note)))

;; Restore previous note from history
(defn restore-previous-note! []
  (let [history (:note-history @notes-state)]
    (if (empty? history)
      nil
      (let [previous-note (last history)
            new-history (vec (butlast history))]
        (swap! notes-state assoc 
               :current-note previous-note
               :note-history new-history)
        previous-note))))

;; Clear current note
(defn clear-current-note! []
  (swap! notes-state assoc :current-note nil))

;; Clear note history
(defn clear-note-history! []
  (swap! notes-state assoc :note-history []))

;; Load more notes
(defn load-more-notes! [ctx]
  (helpers/load-more-helper! ctx notes-state
    (fn [page page-size]
      (db/get-notes-paginated page page-size))))

;; ===== Notes State Queries =====

;; Get notes state
(defn get-notes-state []
  (helpers/get-state notes-state))

;; Get notes list
(defn get-notes []
  (:results @notes-state))

;; Get current note
(defn get-current-note []
  (:current-note @notes-state))

;; Check if loading
(defn is-loading? []
  (helpers/is-loading? notes-state))

;; Check if loading more
(defn is-loading-more? []
  (helpers/is-loading-more? notes-state))

;; Check if has more
(defn has-more? []
  (helpers/has-more? notes-state))

;; Get error
(defn get-error []
  (helpers/get-error notes-state))

;; Get current page
(defn get-current-page []
  (helpers/get-current-page notes-state))

;; Get total count
(defn get-total-count []
  (helpers/get-total-count notes-state))

;; Get page size
(defn get-page-size []
  (helpers/get-page-size notes-state))


;; Set filter tag
(defn set-filter-tag! [tag]
  (swap! notes-state assoc :filter-tag-id (get tag "id"))
  (swap! notes-state assoc :filter-tag-name (get tag "name")))

;; Set filter date
(defn set-filter-date! [date]
  (swap! notes-state assoc :filter-date date))

;; Clear filter
(defn clear-filter! []
  (swap! notes-state assoc :filter-tag-id nil :filter-tag-name nil :filter-date nil))

;; ===== Notes State Reset =====

;; Reset notes state
(defn reset-notes-state! []
  (helpers/reset-state! notes-state
    {:notes []
     :current-note nil}))

(defn get-notes-for-stream []
  (let [limit 20]
    (db/get-notes-paginated 0 limit)))

(defn handle-notes-result-for-stream [notes]
  (helpers/handle-pagination-result! notes-state 0 notes 20))