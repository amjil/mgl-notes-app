(ns notes-app.states.notes
  (:require
   [notes-app.services.database :as db]
   [notes-app.states.global :as gs]
   [notes-app.utils.tag :as tag]
   [notes-app.utils.diff :as diff]
   [clojure.string :as str]))

;; ==================== State definition ====================
;; Notes state management for handling note operations and UI state

(def notes-state
  (atom {:notes []
         :current-note nil
         :loading false
         :error nil
         ;; Pagination state
         :pagination {:page 1
                     :pageSize 20
                     :totalCount 0
                     :totalPages 0
                     :hasNext false
                     :hasPrevious false}
         ;; Infinite scroll state
         :infinite-scroll {:loading-more false
                          :has-more true
                          :all-loaded false}}))

(declare get-notes)

;; ==================== Common utility functions ====================

;; Handle error in note operations
(defn handle-error [error]
  (swap! notes-state assoc :error (str error) :loading false)
  (dart:core/print (str "Notes operation error: " error)))

;; Handle success in note operations
(defn handle-success [data]
  (swap! notes-state assoc 
         :notes data 
         :loading false 
         :error nil))

;; Handle paginated success in note operations
(defn handle-paginated-success [data]
  (swap! notes-state assoc 
         :notes (:notes data)
         :pagination {:page (:page data)
                     :pageSize (:pageSize data)
                     :totalCount (:totalCount data)
                     :totalPages (:totalPages data)
                     :hasNext (:hasNext data)
                     :hasPrevious (:hasPrevious data)}
         :loading false 
         :error nil))

;; Handle infinite scroll success
(defn handle-infinite-scroll-success [data append?]
  (if append?
    ;; Append new notes to existing ones
    (swap! notes-state update :notes concat (:notes data))
    ;; Replace notes (for new searches)
    (swap! notes-state assoc :notes (:notes data)))
  
  (swap! notes-state assoc 
         :pagination {:page (:page data)
                     :pageSize (:pageSize data)
                     :totalCount (:totalCount data)
                     :totalPages (:totalPages data)
                     :hasNext (:hasNext data)
                     :hasPrevious (:hasPrevious data)}
         :infinite-scroll {:loading-more false
                          :has-more (:hasNext data)
                          :all-loaded (not (:hasNext data))}
         :loading false 
         :error nil))

;; ==================== Note CRUD operations ====================

;; Load all notes
(defn load-notes []
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [notes (await (db/get-all-notes))]
      (handle-success notes))
    (catch Exception e
      (handle-error e))))

;; Load all notes with pagination
(defn load-notes-paginated [& {:keys [page pageSize]
                               :or {page 1 pageSize 20}}]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [result (await (db/get-all-notes-paginated :page page :pageSize pageSize))]
      (handle-paginated-success result))
    (catch Exception e
      (handle-error e))))

;; Initialize notes with pagination
(defn init-notes []
  (load-notes-paginated :page 1 :pageSize 20))

;; Load more notes for infinite scroll
(defn load-more-notes [& {:keys [append?]
                          :or {append? true}}]
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)
        has-more (:has-more (:infinite-scroll @notes-state))]
    (when (and has-more (not (:loading-more (:infinite-scroll @notes-state))))
      (swap! notes-state assoc-in [:infinite-scroll :loading-more] true)
      (try
        (let [result (await (db/get-all-notes-paginated :page (inc current-page) :pageSize page-size))]
          (handle-infinite-scroll-success result append?))
        (catch Exception e
          (swap! notes-state assoc-in [:infinite-scroll :loading-more] false)
          (handle-error e))))))

;; Create a new note
(defn create-note [note-data]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [note (await (db/create-note note-data))
          current-notes (:notes @notes-state)]
      (swap! notes-state assoc 
             :notes (conj current-notes note)
             :current-note note
             :loading false
             :error nil)
      note) 
    (catch Exception e
      (handle-error e))))

;; Update an existing note
(defn update-note [note]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (await (db/update-note note))
    (let [current-notes (:notes @notes-state)
          updated-notes (map (fn [n]
                              (if (= (.-id n) (.-id note))
                                note
                                n))
                            current-notes)]
      (swap! notes-state assoc 
             :notes updated-notes
             :current-note note
             :loading false
             :error nil))
    (catch Exception e
      (handle-error e))))

;; Delete a note
(defn delete-note [id]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (await (db/delete-note id))
    (let [current-notes (:notes @notes-state)
          filtered-notes (filter (fn [n]
                                  (not= (.-id n) id))
                                current-notes)]
      (swap! notes-state assoc 
             :notes filtered-notes
             :current-note nil
             :loading false
             :error nil))
    (catch Exception e
      (handle-error e))))

;; ==================== Note search and filtering ====================

;; Search notes by query
(defn search-notes [query]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [notes (await (db/search-notes query))]
      (handle-success notes))
    (catch Exception e
      (handle-error e))))

;; Search notes by query with pagination
(defn search-notes-paginated [query & {:keys [page pageSize]
                                       :or {page 1 pageSize 20}}]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [result (await (db/search-notes-paginated query :page page :pageSize pageSize))]
      (handle-paginated-success result))
    (catch Exception e
      (handle-error e))))

;; Search notes with infinite scroll
(defn search-notes-infinite [query & {:keys [append?]
                                     :or {append? false}}]
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)
        has-more (:has-more (:infinite-scroll @notes-state))]
    (when (and has-more (not (:loading-more (:infinite-scroll @notes-state))))
      (swap! notes-state assoc-in [:infinite-scroll :loading-more] true)
      (try
        (let [result (await (db/search-notes-paginated query :page (inc current-page) :pageSize page-size))]
          (handle-infinite-scroll-success result append?))
        (catch Exception e
          (swap! notes-state assoc-in [:infinite-scroll :loading-more] false)
          (handle-error e))))))

;; Get notes by date
(defn get-notes-by-date [date]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [notes (await (db/get-notes-by-date date))]
      (handle-success notes))
    (catch Exception e
      (handle-error e))))

;; Get notes by date with pagination
(defn get-notes-by-date-paginated [date & {:keys [page pageSize]
                                           :or {page 1 pageSize 20}}]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [result (await (db/get-notes-by-date-paginated date :page page :pageSize pageSize))]
      (handle-paginated-success result))
    (catch Exception e
      (handle-error e))))

;; Get notes by date with infinite scroll
(defn get-notes-by-date-infinite [date & {:keys [append?]
                                         :or {append? false}}]
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)
        has-more (:has-more (:infinite-scroll @notes-state))]
    (when (and has-more (not (:loading-more (:infinite-scroll @notes-state))))
      (swap! notes-state assoc-in [:infinite-scroll :loading-more] true)
      (try
        (let [result (await (db/get-notes-by-date-paginated date :page (inc current-page) :pageSize page-size))]
          (handle-infinite-scroll-success result append?))
        (catch Exception e
          (swap! notes-state assoc-in [:infinite-scroll :loading-more] false)
          (handle-error e))))))

;; Get notes by tag
(defn get-notes-by-tag [tag-name]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [notes (await (db/get-notes-by-tag tag-name))]
      (handle-success notes))
    (catch Exception e
      (handle-error e))))

;; Get notes by tag with pagination
(defn get-notes-by-tag-paginated [tag-name & {:keys [page pageSize]
                                              :or {page 1 pageSize 20}}]
  (swap! notes-state assoc :loading true :error nil)
  (try
    (let [result (await (db/get-notes-by-tag-paginated tag-name :page page :pageSize pageSize))]
      (handle-paginated-success result))
    (catch Exception e
      (handle-error e))))

;; Get notes by tag with infinite scroll
(defn get-notes-by-tag-infinite [tag-name & {:keys [append?]
                                            :or {append? false}}]
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)
        has-more (:has-more (:infinite-scroll @notes-state))]
    (when (and has-more (not (:loading-more (:infinite-scroll @notes-state))))
      (swap! notes-state assoc-in [:infinite-scroll :loading-more] true)
      (try
        (let [result (await (db/get-notes-by-tag-paginated tag-name :page (inc current-page) :pageSize page-size))]
          (handle-infinite-scroll-success result append?))
        (catch Exception e
          (swap! notes-state assoc-in [:infinite-scroll :loading-more] false)
          (handle-error e))))))

;; ==================== Current note management ====================

;; Set the current note
(defn set-current-note [note]
  (swap! notes-state assoc :current-note note))

;; Clear the current note
(defn clear-current-note []
  (swap! notes-state assoc :current-note nil))

;; Get the current note
(defn get-current-note []
  (:current-note @notes-state))

;; ==================== State getters ====================

;; Get all notes
(defn get-notes []
  (:notes @notes-state))

;; Get loading state
(defn get-loading []
  (:loading @notes-state))

;; Get error state
(defn get-error []
  (:error @notes-state))

;; ==================== Pagination state getters ====================

;; Get pagination state
(defn get-pagination []
  (:pagination @notes-state))

;; Get current page
(defn get-current-page []
  (:page (:pagination @notes-state)))

;; Get page size
(defn get-page-size []
  (:pageSize (:pagination @notes-state)))

;; Get total count
(defn get-total-count []
  (:totalCount (:pagination @notes-state)))

;; Get total pages
(defn get-total-pages []
  (:totalPages (:pagination @notes-state)))

;; Check if has next page
(defn has-next-page? []
  (:hasNext (:pagination @notes-state)))

;; Check if has previous page
(defn has-previous-page? []
  (:hasPrevious (:pagination @notes-state)))

;; ==================== Infinite scroll state getters ====================

;; Get infinite scroll state
(defn get-infinite-scroll []
  (:infinite-scroll @notes-state))

;; Check if loading more
(defn loading-more? []
  (:loading-more (:infinite-scroll @notes-state)))

;; Check if has more data
(defn has-more? []
  (:has-more (:infinite-scroll @notes-state)))

;; Check if all loaded
(defn all-loaded? []
  (:all-loaded (:infinite-scroll @notes-state)))

;; ==================== Pagination navigation ====================

;; Go to next page
(defn next-page []
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)]
    (when (:hasNext current-pagination)
      (load-notes-paginated :page (inc current-page) :pageSize page-size))))

;; Go to previous page
(defn previous-page []
  (let [current-pagination (:pagination @notes-state)
        current-page (:page current-pagination)
        page-size (:pageSize current-pagination)]
    (when (:hasPrevious current-pagination)
      (load-notes-paginated :page (dec current-page) :pageSize page-size))))

;; Go to specific page
(defn go-to-page [page]
  (let [current-pagination (:pagination @notes-state)
        page-size (:pageSize current-pagination)]
    (when (and (>= page 1) (<= page (:totalPages current-pagination)))
      (load-notes-paginated :page page :pageSize page-size))))

;; Change page size
(defn change-page-size [new-page-size]
  (load-notes-paginated :page 1 :pageSize new-page-size))

;; ==================== Note saving business logic ====================

;; Core business logic function for saving notes
;; content: note content text
;; old-blocks: optional old block list (for diff updates)
(defn save-note [content & [old-blocks]]
  (let [tags (tag/extract-tags content)
        current-note (get-current-note)]
    (when (not (str/blank? content))
      (try
        (swap! notes-state assoc :loading true :error nil)
        
        (if current-note
          ;; Update existing note
          (let [current-note-id (.-id current-note)]
            (if old-blocks
              ;; Use diff algorithm to update blocks
              (let [block-map (diff/rebuild-blocks-from-diff old-blocks content)]
                ;; Update modified blocks
                (doseq [block (:modified block-map)]
                  (let [existing-block (await (db/get-block (:block-id block)))]
                    (when existing-block
                      (set! (.-content existing-block) (:content block))
                      (set! (.-tags existing-block) (vec tags))
                      (await (db/update-block existing-block)))))
                ;; Delete removed blocks
                (doseq [block (:deleted block-map)]
                  (await (db/delete-block (.-id block))))
                ;; Add new blocks
                (doseq [block (:added block-map)]
                  (let [block-data {:blockId (:block-id block)
                                   :noteId current-note-id
                                   :content (:content block)
                                   :tags (vec tags)}]
                    (await (db/create-block block-data)))))
              
              ;; No old-blocks, recreate all blocks
              (let [blocks (diff/text-to-blocks content)
                    block-ids (atom [])]
                ;; Delete existing blocks
                (let [existing-blocks (await (db/get-blocks-by-note current-note-id))]
                  (doseq [block existing-blocks]
                    (await (db/delete-block (.-id block)))))
                ;; Create new blocks
                (doseq [block blocks]
                  (let [block-data {:blockId (:block-id block)
                                   :noteId current-note-id
                                   :content (:content block)
                                   :tags (vec tags)}
                        created-block (await (db/create-block block-data))]
                    (when created-block
                      (swap! block-ids conj (.-id created-block)))))
                ;; Update note's block IDs and preview field
                (when (not-empty @block-ids)
                  (await (db/update-note-block-ids current-note-id @block-ids))
                  (await (db/update-note-preview current-note-id)))))
            
            ;; Update note's tags
            (set! (.-tags current-note) (vec tags))
            (update-note current-note))
          
          ;; Create new note
          (let [title (str/trim (first (str/split-lines content)))
                note-data {:title title
                           :tags (vec tags)
                           :scheduledDate nil}
                note (create-note note-data)]
            ;; Create blocks
            (when note
              (let [blocks (diff/text-to-blocks content)
                    block-ids (atom [])]
                ;; Create database records for each block
                (doseq [block blocks]
                  (let [block-data {:blockId (:block-id block)
                                   :noteId (.-id note)
                                   :content (:content block)
                                   :tags (vec tags)}
                        created-block (await (db/create-block block-data))]
                    (when created-block
                      (swap! block-ids conj (.-id created-block)))))
                ;; Update note's block IDs and preview field
                (when (not-empty @block-ids)
                  (await (db/update-note-block-ids (.-id note) @block-ids))
                  (await (db/update-note-preview (.-id note))))))))
        
        (swap! notes-state assoc :loading false :error nil)
        {:success true}
        (catch Exception e
          (handle-error e)
          {:success false :error (str e)})))))