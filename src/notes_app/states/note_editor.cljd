(ns notes-app.states.note-editor
  (:require
   [notes-app.states.database :refer [db-state]]
   [notes-app.utils.diff :as diff])
  (:import [dart:core DateTime]))

;; Note editor state management
;; Handles the complete process of editing notes

;; Editor state
(def editor-state
  (atom {:current-note nil
         :current-blocks []
         :has-changes false
         :saving false
         :error nil
         :last-saved nil}))

;; Load note into editor
(defn load-note-to-editor! [note-id]
  (swap! editor-state assoc :saving true :error nil)
  (try
    (let [db-service (:database-service @db-state)
          note-with-blocks (await (.getNoteWithBlocks db-service note-id))
          note (:note note-with-blocks)
          blocks (:blocks note-with-blocks)]
      (swap! editor-state assoc
             :current-note note
             :current-blocks blocks
             :saving false
             :has-changes false))
    (catch :default e
      (swap! editor-state assoc
             :saving false
             :error (str "Failed to load note: " e)))))

;; Check if content has changed
(defn check-content-changed! [new-text]
  (let [current-blocks (:current-blocks @editor-state)
        has-changed (diff/has-text-changed? current-blocks new-text)]
    (swap! editor-state assoc :has-changes has-changed)
    has-changed))

;; Save note (full process)
(defn save-note! [new-content & [title]]
  (swap! editor-state assoc :saving true :error nil)
  (try
    (let [current-note (:current-note @editor-state)
          current-blocks (:current-blocks @editor-state)
          db-service (:database-service @db-state)]
      (if current-note
        ;; Update existing note
        (let [success (await (.updateNoteWithBlocks db-service
                                                   {:noteId (:id current-note)
                                                    :newContent new-content
                                                    :title title
                                                    :oldBlocks (mapv (fn [block]
                                                                      {:id (:id block)
                                                                       :content (:content block)})
                                                                    current-blocks)}))]
          (if success
            (do
              (swap! editor-state assoc
                     :saving false
                     :has-changes false
                     :last-saved (DateTime/now))
              ;; Reload note data
              (load-note-to-editor! (:id current-note))
              {:success true})
            (do
              (swap! editor-state assoc
                     :saving false
                     :error "Failed to save note")
              {:success false :error "Failed to save note"})))
        ;; Create new note
        (let [note-id (await (.createNoteWithBlocks db-service
                                                   {:title (or title "New Note")
                                                    :content new-content}))]
          (if note-id
            (do
              (swap! editor-state assoc
                     :saving false
                     :has-changes false
                     :last-saved (DateTime/now))
              ;; Load the newly created note
              (load-note-to-editor! note-id)
              {:success true :note-id note-id})
            (do
              (swap! editor-state assoc
                     :saving false
                     :error "Failed to create note")
              {:success false :error "Failed to create note"})))))
    (catch :default e
      (swap! editor-state assoc
             :saving false
             :error (str "Failed to save note: " e))
      {:success false :error (str "Failed to save note: " e)})))

;; Use diff tool to process content changes
(defn process-content-change [new-text]
  (let [current-blocks (:current-blocks @editor-state)
        diff-result (diff/rebuild-blocks-from-diff current-blocks new-text)]
    diff-result))

;; Get current editor state
(defn get-editor-state []
  @editor-state)

(defn get-current-note []
  (:current-note @editor-state))

(defn get-current-blocks []
  (:current-blocks @editor-state))

(defn has-changes? []
  (:has-changes @editor-state))

(defn is-saving? []
  (:saving @editor-state))

(defn get-error []
  (:error @editor-state))

;; Clear editor state
(defn clear-editor! []
  (reset! editor-state {:current-note nil
                        :current-blocks []
                        :has-changes false
                        :saving false
                        :error nil
                        :last-saved nil}))

;; Set error state
(defn set-error! [error]
  (swap! editor-state assoc :error error))

;; Clear error state
(defn clear-error! []
  (swap! editor-state assoc :error nil)) 