(ns notes-app.services.db
  "Database service - provides abstract interface for all database operations"
  (:require
   ["dart:core" :as dart-core]
   ["package:cljd_mgl_notes_app/database/database.dart" :as drift]
   ["package:drift/drift.dart" :as d]
   ["package:uuid/uuid.dart" :as uuid]
   
   [clojure.string :as str]
   [notes-app.utils.string :as string-utils]
   [electric-sync.state :as es-state]))

;; =============================================================================
;; Database Instance Management
;; =============================================================================

(declare get-blocks-by-note-id update-block-content)

;; Database instance reference
(def db (atom nil))

;; UUID generator instance
(def ^uuid/Uuid uuid-instance (uuid/Uuid.))

(defn initialize-database!
  "Initialize database instance"
  []
  (reset! db (await (drift/initDriftDatabase))))

;; =============================================================================
;; Helper Functions
;; =============================================================================

(defn ^:private get-user-id-if-available
  "Get user_id from electric-sync token if available and not empty"
  []
  (let [uid @es-state/uid]
    (if (empty? uid)
      ""
      uid)))

(defn to-timestamp [time-str]
  ;; Replace space with "T" because DateTime.parse requires ISO8601 format
  (when-not (empty? time-str)
    (let [iso-str (.replaceAll time-str " " "T")
          dt (dart-core/DateTime.parse iso-str)
          utc-dt (.toUtc dt)
          timestamp (int (/ (.millisecondsSinceEpoch utc-dt) 1000))]
      timestamp)))

(defn- datetime->sql-param [^dart-core/DateTime dt]
  (when dt
    (.toIso8601String dt)))

(defn upsert-remote-note!
  "Insert or replace note record with data pulled from remote"
  [{:keys [id title block_ids created_at updated_at deleted_at is_deleted user_id]}]
  (dart:core/print (str "start upsert-remote-note! id = " id " title = " title " block_ids = " block_ids " created_at = " created_at " updated_at = " updated_at " deleted_at = " deleted_at " is_deleted = " is_deleted " user_id = " user_id))
  (when id
    (dart:core/print (str "id111 = " id))
    (let [^drift/AppDatabase db @db
          block-ids (or block_ids "[]")
          created-at (to-timestamp created_at)
          updated-at (or (to-timestamp updated_at) created-at)
          deleted-at (to-timestamp deleted_at)
          is-deleted (if (boolean? is_deleted)
                       is_deleted
                       (= "true" (str/lower-case (str is_deleted))))
          user-id (when (and user_id (not (str/blank? user_id))) user_id)]
      (dart:core/print (str "upsert-remote-note! id = " id " title = " title " block_ids = " block_ids " created_at = " created_at " updated_at = " updated_at " deleted_at = " deleted_at " is_deleted = " is_deleted " user_id = " user_id))
      (.customStatement db
                        "INSERT OR REPLACE INTO notes 
                         (id, title, block_ids, created_at, updated_at, is_deleted, deleted_at, user_id, sync_status, synced_at)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
                        [id
                         (or title "")
                         block-ids
                         created-at
                         updated-at
                         is-deleted
                         deleted-at
                         user-id
                         "synced"
                         updated-at]))))
                   
(defn upsert-remote-block!
  "Insert or replace block record with data pulled from remote"
  [{:keys [id note_id content created_at updated_at user_id]}]
  (when (and id note_id)
    (let [^drift/AppDatabase db @db
          created-at (to-timestamp created_at)
          updated-at (or (to-timestamp updated_at) created-at)
          user-id (when (and user_id (not (str/blank? user_id))) user_id)
          block-content (or content "")]
      (.customStatement db
                        "INSERT OR REPLACE INTO blocks 
                         (id, note_id, content, created_at, updated_at, user_id, sync_status)
                         VALUES (?, ?, ?, ?, ?, ?, ?)"
                        [id
                         note_id
                         block-content
                         created-at
                         updated-at
                         user-id
                         "synced"])
      (update-block-content id block-content))))

;; =============================================================================
;; Basic Note Operations
;; =============================================================================

(defn create-note
  "Create new note"
  [^String id ^String title]
  (let [^drift/AppDatabase db @db
        ^String 
        user-id (get-user-id-if-available)
        companion (if-not (empty? user-id)
                    (drift/NotesCompanion.insert
                     .id id
                     .title title
                     .userId (d/Value user-id))
                    (drift/NotesCompanion.insert
                     .id id
                     .title title))]
    (.insert
     (.into db (.-notes db))
     companion)))

;; =============================================================================
;; Note Query Operations
;; =============================================================================

(defn get-notes-paginated
  "Get paginated note list"
  [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.*, nfts.content as content, 
        case 
         when f.note_id is not null then true 
         else false 
        end as favorite
        FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        LEFT JOIN favorite_notes f ON n.id = f.note_id
        WHERE n.is_deleted = false " user-filter "
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?")
      .variables (if-not (empty? user-id)
                   [(d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                   [(d/Variable limit) (d/Variable offset)])))))

(defn get-notes-by-tag
  "Get notes by tag with pagination"
  [tag-id page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        ^String
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        INNER JOIN note_tags nt ON n.id = nt.note_id
        WHERE nt.tag_id = ? AND n.is_deleted = false " user-filter "
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?")
      .variables (if-not (empty? user-id)
                   [(d/Variable tag-id) (d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                   [(d/Variable tag-id) (d/Variable limit) (d/Variable offset)])))))

(defn get-notes-by-date
  "Get notes by date with pagination"
  [date page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        WHERE CAST(strftime('%Y%m%d', created_at, 'unixepoch') AS INTEGER) = ? 
             AND n.is_deleted = false " user-filter "
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?")
      .variables (if-not (empty? user-id)
                   [(d/Variable date) (d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                   [(d/Variable date) (d/Variable limit) (d/Variable offset)])))))

(defn get-pending-notes
  "Get notes pending synchronization"
  []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect db
                    (str "SELECT n.* FROM notes n 
                     WHERE n.sync_status = 'pending' and is_deleted = false " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

(defn get-all-notes
  "Get all notes"
  []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)]
    (.get
     (doto (.select db (.-notes db))
       (.where (fn [^drift/Notes tbl]
                 (if-not (empty? user-id)
                   (and (.equals (.-isDeleted tbl) false)
                        (.equals (.-userId tbl) user-id))
                   (and (.equals (.-isDeleted tbl) false)
                        (.isNull (.-userId tbl))))))
       (.orderBy [(fn [^drift/Notes tbl] (d/OrderingTerm. .expression (.-updatedAt tbl) .mode d/OrderingMode.desc))])))))

;; =============================================================================
;; Note Update Operations
;; =============================================================================

(defn update-note
  "Update note title"
  [id ^String title]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                     .title (d/Value title)
                     .syncStatus (d/Value "pending"))]
    (.write query companion)))

(defn update-note-block-ids
  "Update note blocks synchronization status"
  [id ^String block-ids]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .blockIds (d/Value block-ids))]
    (.write query companion)))

;; =============================================================================
;; Note Content Operations
;; =============================================================================

(defn create-note-content
  "Create note content"
  [^String id ^String content]
  (dart:core/print (str "insert-note-content id = " id " content = " content))
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "INSERT INTO note_fts (id, content) VALUES (?, ?)"
                      [id content])))

(defn update-note-content
  "Update note content"
  [^String id ^String content]
  (dart:core/print (str "update-note-content id = " id " content = " content))
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "update note_fts SET content = ? where id = ?"
                      [content id])))

;; =============================================================================
;; Note Delete and Restore Operations
;; =============================================================================

(defn soft-delete-note
  "Soft delete note (mark as deleted)"
  [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .isDeleted (d/Value true))]
    (.write query companion)))

;; =============================================================================
;; Note Delete and Restore Operations
;; =============================================================================

(defn hard-delete-note
  "Hard delete note (permanently remove from database)"
  [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-notes db))
       (.where (fn [^drift/Notes tbl]
                 (.equals (.-id tbl) id)))))
    (.customStatement db
                      "DELETE FROM note_fts WHERE id = ?"
                      [id])))

(defn restore-note
  "Restore deleted note"
  [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .isDeleted (d/Value false))]
    (.write query companion)))

(defn get-deleted-notes
  "Get paginated deleted notes"
  [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        WHERE n.is_deleted = true " user-filter "
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?")
      .variables (if-not (empty? user-id)
                   [(d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                   [(d/Variable limit) (d/Variable offset)])))))

;; =============================================================================
;; Note Search and Statistics
;; =============================================================================

(defn search-notes
  "Search notes"
  [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id  
        WHERE n.is_deleted = false
           and n.id in (select id from note_fts where content match ?) " user-filter "
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?")
      .variables (if-not (empty? user-id)
                   [(d/Variable query) (d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                   [(d/Variable query) (d/Variable limit) (d/Variable offset)])))))

(defn search-notes-by-title
  "Search notes by title using LIKE query, returns id and title"
  [{:keys [query]}]
  (let [^drift/AppDatabase db @db
        title-pattern (str "%" query "%")
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.id, n.title FROM notes n 
        WHERE n.title LIKE ? AND n.is_deleted = false " user-filter "
        ORDER BY n.updated_at DESC")
      .variables (if-not (empty? user-id)
                   [(d/Variable title-pattern) (d/Variable user-id)]
                   [(d/Variable title-pattern)])))))

(defn get-note-by-title
  "Get note by exact title match, returns note with id and title"
  [title]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.getSingle
     (.customSelect
      db
      (str "SELECT n.id, n.title FROM notes n 
        WHERE n.title = ? AND n.is_deleted = false " user-filter)
      .variables (if-not (empty? user-id)
                   [(d/Variable title) (d/Variable user-id)]
                   [(d/Variable title)])))))

(defn get-notes-count
  "Get total notes count"
  []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND user_id = ?"
                      "AND user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str "SELECT COUNT(*) as count FROM notes WHERE is_deleted = false " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

(defn get-notes-count-by-search [query]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str "SELECT COUNT(*) as count FROM notes n
                      INNER JOIN note_fts nfts ON n.id = nfts.id 
                      WHERE nfts.content MATCH ? AND n.is_deleted = false " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable query) (d/Variable user-id)]
                                 [(d/Variable query)])))))

;; ===== Blocks db functions =====

(defn create-block
  ([note-id content]
   (create-block note-id content (.v4 uuid-instance)))
  ([note-id content id]
   (let [^drift/AppDatabase db @db
         ^String
         user-id (get-user-id-if-available)
         companion (if-not (empty? user-id)
                     (drift/BlocksCompanion.insert
                      .id id
                      .noteId note-id
                      .content content
                      .userId (d/Value user-id))
                     (drift/BlocksCompanion.insert
                      .id id
                      .noteId note-id
                      .content content))]
     (.insert
      (.into db (.-blocks db))
      companion))))

(defn get-block-by-id [id]
  (let [^drift/AppDatabase db @db]
    (.getSingleOrNull
     (doto (.select db (.-blocks db))
       (.where (fn [^drift/Blocks tbl] (.equals (.-id tbl) id)))))))

(defn get-blocks-by-note-id [note-id]
  (let [^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-blocks db))
       (.where (fn [^drift/Blocks tbl] (.equals (.-noteId tbl) note-id)))
       (.orderBy [(fn [^drift/Blocks tbl] (d/OrderingTerm. .expression (.-createdAt tbl) .mode d/OrderingMode.asc))])))))

(defn get-pending-blocks
  "Get blocks pending synchronization"
  []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND b.user_id = ?"
                      "AND b.user_id IS NULL")]
    (.get
     (.customSelect db
                    (str "SELECT b.* FROM blocks b 
                     INNER JOIN notes n ON b.note_id = n.id
                     WHERE b.sync_status = 'pending' and n.id is not null and n.is_deleted = false " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

(defn update-block [id ^String content]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-blocks db))
                (.where (fn [^drift/Blocks tbl]
                          (.equals (.-id tbl) id))))
        companion (drift/BlocksCompanion.
                   .content (d/Value content)
                   .syncStatus (d/Value "pending"))]
    (.write query companion)))

;; Mark block as synced
(defn mark-block-as-synced [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-blocks db))
                (.where (fn [^drift/Blocks tbl]
                          (.equals (.-id tbl) id))))
        companion (drift/BlocksCompanion.
                   .syncStatus (d/Value "synced"))]
    (.write query companion)))

(defn update-block-content [id ^String content]
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "INSERT OR REPLACE INTO blocks_fts (id, content) VALUES (?, ?)"
                      [id content])))

(defn delete-block [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-blocks db))
       (.where (fn [^drift/Blocks tbl]
                 (.equals (.-id tbl) id)))))
    (.customStatement db
                      "DELETE FROM blocks_fts WHERE id = ?"
                      [id])))

(defn search-blocks [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT b.*, bfts.content as content FROM blocks b 
        LEFT JOIN blocks_fts bfts ON b.id = bfts.id 
        WHERE bfts.content MATCH ?
        ORDER BY b.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable query) (d/Variable limit) (d/Variable offset)]))))

(defn get-blocks-count []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM blocks"))))

;; ===== Tags db functions =====

(defn create-tag [name & [id]]
  (let [id (or id (.v4 uuid-instance))
        ^drift/AppDatabase db @db
        ^String 
        user-id (get-user-id-if-available)
        companion (if-not (empty? user-id)
                    (drift/TagsCompanion.insert
                     .id id
                     .name name
                     .userId (d/Value user-id))
                    (drift/TagsCompanion.insert
                     .id id
                     .name name))]
    (.insert
     (.into db (.-tags db))
     companion)))

(defn get-tag-by-id [id]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)]
    (.getSingleOrNull
     (doto (.select db (.-tags db))
       (.where (fn [^drift/Tags tbl]
                 (if-not (empty? user-id)
                   (and (.equals (.-id tbl) id)
                        (.equals (.-userId tbl) user-id))
                   (and (.equals (.-id tbl) id)
                        (.isNull (.-userId tbl))))))))))

(defn get-tag-by-name [name]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        query (if-not (empty? user-id)
                " SELECT * FROM tags WHERE name = ? AND user_id = ? LIMIT 1 "
                " SELECT * FROM tags WHERE name = ? AND user_id IS NULL LIMIT 1 ")
        variables (if-not (empty? user-id)
                    [(d/Variable name) (d/Variable user-id)]
                    [(d/Variable name)])]
    (.getSingleOrNull
     (.customSelect db query .variables variables))))

(defn get-all-tags []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)]
    (.get
     (doto (.select db (.-tags db))
       (.where (fn [^drift/Tags tbl]
                 (if-not (empty? user-id)
                   (.equals (.-userId tbl) user-id)
                   (.isNull (.-userId tbl)))))
       (.orderBy [(fn [^drift/Tags tbl] (d/OrderingTerm. .expression (.-name tbl) .mode d/OrderingMode.asc))])))))

(defn get-tags-paginated [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)]
    (.get
     (doto (.select db (.-tags db))
       (.where (fn [^drift/Tags tbl]
                 (if-not (empty? user-id)
                   (.equals (.-userId tbl) user-id)
                   (.isNull (.-userId tbl)))))
       (.orderBy [(fn [^drift/Tags tbl] (d/OrderingTerm. .expression (.-name tbl) .mode d/OrderingMode.asc))])
       (.limit limit .offset offset)))))

(defn update-tag [id name]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-tags db))
                (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id))))
        companion (drift/TagsCompanion.
                   .name name)]
    (.write query companion)))

(defn delete-tag [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-tags db))
       (.where (fn [^drift/Tags tbl]
                 (.equals (.-id tbl) id)))))))

(defn search-tags [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND user_id = ?"
                      "AND user_id IS NULL")]
    (.get
     (.customSelect db 
                    (str " SELECT * FROM TAGS 
                     WHERE NAME LIKE ? " user-filter "
                     ORDER BY NAME ASC 
                     LIMIT ? OFFSET ?")
                    .variables (if-not (empty? user-id)
                                 [(d/Variable query) (d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                                 [(d/Variable query) (d/Variable limit) (d/Variable offset)])))))

(defn get-tags-count []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "WHERE user_id = ?"
                      "WHERE user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str " SELECT COUNT (*) as count FROM tags " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

;; ===== NoteTags db functions =====

(defn add-tag-to-note [note-id tag-id]
  (let [^drift/AppDatabase db @db
        ^String
        user-id (get-user-id-if-available)
        companion (if-not (empty? user-id)
                    (drift/NoteTagsCompanion.insert
                     .noteId note-id
                     .tagId tag-id
                     .userId (d/Value user-id))
                    (drift/NoteTagsCompanion.insert
                     .noteId note-id
                     .tagId tag-id))]
    (.insert
     (.into db (.-noteTags db))
     companion)))

(defn remove-tag-from-note [note-id tag-id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-noteTags db))
       (.where (fn [^drift/NoteTags tbl]
                 (and
                  (.equals (.-noteId tbl) note-id)
                  (.equals (.-tagId tbl) tag-id))))))))

(defn get-note-tags [note-id]
  (let [^drift/AppDatabase db @db]
     (.get
      (.customSelect
       db
       " SELECT t.* FROM tags t
         INNER JOIN note_tags nt ON t.id = nt.tag_id
         WHERE nt.note_id = ?
         ORDER BY t.name ASC "
       .variables
       [(d/Variable note-id)]))))

(defn get-tagged-notes [tag-id page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect db
                    (str " SELECT n.*, nfts.content as content FROM notes n
                      LEFT JOIN note_fts nfts ON n.id = nfts.id
                      INNER JOIN note_tags nt ON n.id = nt.note_id
                      WHERE nt.tag_id = ? AND n.is_deleted = false " user-filter "
                      ORDER BY n.updated_at DESC
                      LIMIT ? OFFSET ? ")
                    .variables
                    (if-not (empty? user-id)
                      [(d/Variable tag-id) (d/Variable user-id) (d/Variable limit) (d/Variable offset)]
                      [(d/Variable tag-id) (d/Variable limit) (d/Variable offset)])))))

(defn get-notes-by-tags [tag-ids page limit]
  (let [offset (* page limit)
        placeholders (clojure.string/join "," (repeat (count tag-ids) " ? "))
        ^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect db
                    (str " SELECT n.*, nfts.content as content FROM notes n
                           LEFT JOIN note_fts nfts ON n.id = nfts.id
                           INNER JOIN note_tags nt ON n.id = nt.note_id
                           WHERE nt.tag_id IN (" placeholders ") AND n.is_deleted = false " user-filter "
                           GROUP BY n.id
                           HAVING COUNT (DISTINCT nt.tag_id) = ?
                           ORDER BY n.updated_at DESC
                           LIMIT ? OFFSET ? ")
                    .variables
                    (if-not (empty? user-id)
                      (concat (map d/Variable tag-ids) [(d/Variable user-id) (d/Variable (count tag-ids)) (d/Variable limit) (d/Variable offset)])
                      (concat (map d/Variable tag-ids) [(d/Variable (count tag-ids)) (d/Variable limit) (d/Variable offset)]))))))

(defn get-tagged-notes-count [tag-id]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str " SELECT COUNT (*) as count FROM note_tags nt
                      INNER JOIN notes n ON nt.note_id = n.id
                      WHERE nt.tag_id = ? AND n.is_deleted = false " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable tag-id) (d/Variable user-id)]
                                 [(d/Variable tag-id)])))))

;; Create note with content (4 steps: note, note_fts, blocks, block_ids)
(defn create-note-with-content [^String content & [id]]
  (let [^String id (or id (.v4 uuid-instance))
        ^drift/AppDatabase db @db
        ^String
        title (string-utils/extract-title-from-content content)]
    (.transaction
     db
     (fn []
       (create-note id title)
       (create-note-content id content)))))

;; Update note with content (4 steps: note, note_fts, blocks, block_ids)
(defn update-note-with-content [^String id ^String title ^String content]
  (let [^drift/AppDatabase db @db]
    (.transaction
     db
     (fn []
       (update-note id title)
       (update-note-content id content)))))

;; Mark note as synced
(defn mark-note-as-synced [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .syncStatus (d/Value "synced"))]
    (.write query companion)))

;; Get notes for synchronization
(defn get-notes-for-sync []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)]
    (.get
     (doto (.select db (.-notes db))
       (.where (fn [^drift/Notes tbl]
                 (if-not (empty? user-id)
                   (and (.equals (.-syncStatus tbl) "pending")
                        (.equals (.-userId tbl) user-id))
                   (and (.equals (.-syncStatus tbl) "pending")
                        (.isNull (.-userId tbl))))))
       (.orderBy [(fn [^drift/Notes tbl] (d/OrderingTerm. .expression (.-updatedAt tbl) .mode d/OrderingMode.asc))])))))

;; Get pending notes count
(defn get-pending-notes-count []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND user_id = ?"
                      "AND user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str "SELECT COUNT(*) as count FROM notes WHERE sync_status = 'pending' " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

;; Get synced notes count
(defn get-synced-notes-count []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND user_id = ?"
                      "AND user_id IS NULL")]
    (.getSingle
     (.customSelect db
                    (str "SELECT COUNT(*) as count FROM notes WHERE sync_status = 'synced' " user-filter)
                    .variables (if-not (empty? user-id)
                                 [(d/Variable user-id)]
                                 [])))))

;; =============================================================================
;; Favorite Notes Operations
;; =============================================================================
(defn get-favorite-notes
  "Get all favorite notes as a stream"
  []
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.* FROM notes n
       INNER JOIN favorite_notes fn ON n.id = fn.note_id
       WHERE n.is_deleted = false " user-filter "
       ORDER BY fn.created_at DESC")
      .variables (if-not (empty? user-id)
                   [(d/Variable user-id)]
                   [])))))

(defn add-favorite-note
  "Add note to favorites"
  [note-id]
  (let [^drift/AppDatabase db @db
        ^String
        user-id (get-user-id-if-available)
        companion (if-not (empty? user-id)
                    (drift/FavoriteNotesCompanion.insert
                     .noteId note-id
                     .userId (d/Value user-id))
                    (drift/FavoriteNotesCompanion.insert
                     .noteId note-id))]
    (.insert
     (.into db (.-favoriteNotes db))
     companion
     .mode (d/InsertMode.replace))))

(defn remove-favorite-note
  "Remove note from favorites"
  [note-id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-favoriteNotes db))
       (.where (fn [^drift/FavoriteNotes tbl] (.equals (.-noteId tbl) note-id)))))))

;; =============================================================================
;; Note References Operations
;; =============================================================================

(defn create-note-reference
  "Create note reference (save reference relationship)"
  [note-id referenced-note-id]
  (let [^drift/AppDatabase db @db
        ^String
        user-id (get-user-id-if-available)
        companion (if-not (empty? user-id)
                    (drift/NoteReferencesCompanion.insert
                     .noteId note-id
                     .referencedNoteId referenced-note-id
                     .userId (d/Value user-id))
                    (drift/NoteReferencesCompanion.insert
                     .noteId note-id
                     .referencedNoteId referenced-note-id))]
    (.insert
     (.into db (.-noteReferences db))
     companion
     .mode (d/InsertMode.replace))))

(defn delete-note-reference
  "Delete note reference (remove reference relationship)"
  [note-id referenced-note-id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-noteReferences db))
       (.where (fn [^drift/NoteReferences tbl]
                 (and
                  (.equals (.-noteId tbl) note-id)
                  (.equals (.-referencedNoteId tbl) referenced-note-id))))))))

(defn get-note-references
  "Get note references for a note, returns list with id and title"
  [note-id]
  (let [^drift/AppDatabase db @db
        user-id (get-user-id-if-available)
        user-filter (if-not (empty? user-id)
                      "AND n.user_id = ?"
                      "AND n.user_id IS NULL")]
    (.get
     (.customSelect
      db
      (str "SELECT n.id, n.title FROM notes n
       INNER JOIN note_references nr ON n.id = nr.referenced_note_id
       WHERE nr.note_id = ? AND n.is_deleted = false " user-filter "
       ORDER BY nr.created_at DESC")
      .variables (if-not (empty? user-id)
                   [(d/Variable note-id) (d/Variable user-id)]
                   [(d/Variable note-id)])))))

(defn get-note-reference-ids
  "Get all referenced note IDs for a note, returns list of referenced note IDs"
  [note-id]
  (let [^drift/AppDatabase db @db]
    (-> (.get
         (.customSelect
          db
          "SELECT referenced_note_id FROM note_references WHERE note_id = ?"
          .variables [(d/Variable note-id)]))
        (.then (fn [rows]
                 (if (empty? rows)
                   []
                   (map (fn [row]
                          (let [row (.-data row)]
                            (or (get row "referenced_note_id")
                                (get row :referenced_note_id)
                                (.-referencedNoteId row))))
                        rows)))))))

;; =============================================================================
;; Update User ID for Drift Tables
;; =============================================================================

(defn update-empty-user-ids!
  "Update all drift table records where user_id is null with the provided user_id"
  [user-id]
  (let [^drift/AppDatabase db @db]
    (.transaction
     db
     (fn []
       ;; Update Notes table
       (.customStatement db
                         "UPDATE notes SET user_id = ? WHERE user_id IS NULL"
                         [user-id])
       ;; Update Blocks table
       (.customStatement db
                         "UPDATE blocks SET user_id = ? WHERE user_id IS NULL"
                         [user-id])
       ;; Update Tags table
       (.customStatement db
                         "UPDATE tags SET user_id = ? WHERE user_id IS NULL"
                         [user-id])
       ;; Update NoteTags table
       (.customStatement db
                         "UPDATE note_tags SET user_id = ? WHERE user_id IS NULL"
                         [user-id])
       ;; Update FavoriteNotes table
       (.customStatement db
                         "UPDATE favorite_notes SET user_id = ? WHERE user_id IS NULL"
                         [user-id])
       ;; Update NoteReferences table
       (.customStatement db
                         "UPDATE note_references SET user_id = ? WHERE user_id IS NULL"
                         [user-id])))))