(ns notes-app.services.db
  "Database service - provides abstract interface for all database operations"
  (:require
   ["package:cljd_mgl_notes_app/database/database.dart" :as drift]
   ["package:drift/drift.dart" :as d]
   ["package:uuid/uuid.dart" :as uuid]
   [cljd.dart.isolates :as di]
   [clojure.string :as str]
   [notes-app.utils.string :as string-utils]))

;; =============================================================================
;; Database Instance Management
;; =============================================================================

(declare get-blocks-by-note-id)

;; Database instance reference
(def db (atom nil))

;; UUID generator instance
(def ^uuid/Uuid uuid-instance (uuid/Uuid.))

(defn initialize-database!
  "Initialize database instance"
  []
  (reset! db (await (drift/initDriftDatabase))))

;; =============================================================================
;; Basic Note Operations
;; =============================================================================

(defn create-note
  "Create new note"
  [^String id ^String title]
  (let [^drift/AppDatabase db @db]
    (.insert
     (.into db (.-notes db))
     (drift/NotesCompanion.insert
      .id id
      .title title))))

(defn get-note-by-id
  "Get note basic information by ID"
  [id]
  (let [^drift/AppDatabase db @db]
    (await
     (.getSingleOrNull
      (doto (.select db (.-notes db))
        (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))))))

(defn get-note-with-content-by-id
  "Get note and its content by ID"
  [id]
  (let [^drift/AppDatabase db @db]
    (.getSingleOrNull
     (.customSelect db
                    "SELECT n.*, nfts.content as content FROM notes n 
                      LEFT JOIN note_fts nfts ON n.id = nfts.id 
                      WHERE n.id = ? AND n.is_deleted = false"
                    .variables [(d/Variable id)]))))

;; =============================================================================
;; Note Query Operations
;; =============================================================================

(defn get-notes-paginated
  "Get paginated note list"
  [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        WHERE n.is_deleted = false
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable limit) (d/Variable offset)]))))

(defn get-notes-by-tag
  "Get notes by tag with pagination"
  [tag-id page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        INNER JOIN note_tags nt ON n.id = nt.note_id
        WHERE nt.tag_id = ? AND n.is_deleted = false
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable tag-id) (d/Variable limit) (d/Variable offset)]))))

(defn get-notes-by-date
  "Get notes by date with pagination"
  [date page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        WHERE CAST(strftime('%Y%m%d', created_at, 'unixepoch') AS INTEGER) = ? 
             AND n.is_deleted = false
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable date) (d/Variable limit) (d/Variable offset)]))))

(defn get-notes-by-pending-sync
  "Get notes pending synchronization"
  []
  (let [^drift/AppDatabase db @db]
    (.get
     (.customSelect db
                    "SELECT n.*, nfts.content as content FROM notes n 
                     LEFT JOIN note_fts nfts ON n.id = nfts.id 
                     WHERE n.sync_status = 'pending'"))))

(defn get-all-notes
  "Get all notes"
  []
  (let [^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-notes db))
       (.where (fn [^drift/Notes tbl] (.equals (.-isDeleted tbl) false)))
       (.orderBy [(fn [^drift/Notes tbl] (d/OrderingTerm. .expression (.-updatedAt tbl) .mode d/OrderingMode.desc))])))))

;; =============================================================================
;; Note Update Operations
;; =============================================================================

(defn update-note
  "Update note title"
  [id ^String title & {:keys [base-hash] :or {base-hash nil}}]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                     .title (d/Value title))]
    (.write query companion)))

(defn update-note-blocks-synced
  "Update note blocks synchronization status"
  [id block-ids]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .blockIds (d/Value block-ids))]
    (.write query companion)))

;; =============================================================================
;; Note Content Operations
;; =============================================================================

(defn create-note-content
  "Create note content"
  [^String id ^String content]
  (dart:core/print (str "insert-note-content id = " id " content = " content))
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "INSERT INTO note_fts (id, content) VALUES (?, ?)"
                      [id content])))

(defn update-note-content
  "Update note content"
  [^String id ^String content]
  (dart:core/print (str "update-note-content id = " id " content = " content))
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "update note_fts SET content = ? where id = ?"
                      [content id])))

;; =============================================================================
;; Note Delete and Restore Operations
;; =============================================================================

(defn soft-delete-note
  "Soft delete note (mark as deleted)"
  [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .isDeleted (d/Value true))]
    (.write query companion)))

;; =============================================================================
;; Note Delete and Restore Operations
;; =============================================================================

(defn hard-delete-note
  "Hard delete note (permanently remove from database)"
  [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-notes db))
       (.where (fn [^drift/Notes tbl]
                 (.equals (.-id tbl) id)))))
    (.customStatement db
                      "DELETE FROM note_fts WHERE id = ?"
                      [id])))

(defn restore-note
  "Restore deleted note"
  [id]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-notes db))
                (.where (fn [^drift/Notes tbl] (.equals (.-id tbl) id))))
        companion (drift/NotesCompanion.
                   .isDeleted (d/Value false))]
    (.write query companion)))

(defn get-deleted-notes
  "Get paginated deleted notes"
  [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN note_fts nfts ON n.id = nfts.id 
        WHERE n.is_deleted = true
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable limit) (d/Variable offset)]))))

;; =============================================================================
;; Note Search and Statistics
;; =============================================================================

(defn search-notes
  "Search notes"
  [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT n.*, nfts.content as content FROM notes n 
        LEFT JOIN (SELECT id, content FROM note_fts WHERE content MATCH ?) 
                  nfts ON n.id = nfts.id 
        WHERE n.is_deleted = false
        ORDER BY n.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable query) (d/Variable limit) (d/Variable offset)]))))

(defn get-notes-count
  "Get total notes count"
  []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM notes WHERE is_deleted = false"))))

(defn get-notes-count-by-search [query]
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM notes n
                      INNER JOIN note_fts nfts ON n.id = nfts.id 
                      WHERE nfts.content MATCH ? AND n.is_deleted = false"
                    .variables [(d/Variable query)]))))

(defn get-notes-blocks-not-synced []
  (let [^drift/AppDatabase db @db]
    (.get
     (.customSelect db
                    "SELECT n.*, nfts.content as content FROM notes n 
                     LEFT JOIN note_fts nfts ON n.id = nfts.id 
                     WHERE n.is_blocks_synced = false AND n.is_deleted = false"))))

;; ===== Blocks db functions =====

(defn create-block [note-id content]
  (let [id (.v4 uuid-instance)
        ^drift/AppDatabase db @db]
    (.insert
     (.into db (.-blocks db))
     (drift/BlocksCompanion.insert
      .id id
      .noteId note-id
      .content content))))

(defn get-block-by-id [id]
  (let [^drift/AppDatabase db @db]
    (.getSingleOrNull
     (doto (.select db (.-blocks db))
       (.where (fn [^drift/Blocks tbl] (.equals (.-id tbl) id)))))))

(defn get-blocks-by-note-id [note-id]
  (let [^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-blocks db))
       (.where (fn [^drift/Blocks tbl] (.equals (.-noteId tbl) note-id)))
       (.orderBy [(fn [^drift/Blocks tbl] (d/OrderingTerm. .expression (.-createdAt tbl) .mode d/OrderingMode.asc))])))))

(defn update-block [id content]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-blocks db))
                (.where (fn [^drift/Blocks tbl]
                          (.equals (.-id tbl) id))))
        companion (drift/BlocksCompanion.
                   .content content)]
    (.write query companion)))

(defn update-block-content [id content]
  (let [^drift/AppDatabase db @db]
    (.customStatement db
                      "INSERT OR REPLACE INTO blocks_fts (id, content) VALUES (?, ?)"
                      [id content])))

(defn delete-block [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-blocks db))
       (.where (fn [^drift/Blocks tbl]
                 (.equals (.-id tbl) id)))))
    (.customStatement db
                      "DELETE FROM blocks_fts WHERE id = ?"
                      [id])))

(defn search-blocks [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect
      db
      "SELECT b.*, bfts.content as content FROM blocks b 
        LEFT JOIN blocks_fts bfts ON b.id = bfts.id 
        WHERE bfts.content MATCH ?
        ORDER BY b.updated_at DESC 
        LIMIT ? OFFSET ?"
      .variables [(d/Variable query) (d/Variable limit) (d/Variable offset)]))))

(defn get-blocks-count []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM blocks"))))

;; ===== Tags db functions =====

(defn create-tag [name & [id]]
  (let [id (or id (.v4 uuid-instance))
        ^drift/AppDatabase db @db]
    (.insert
     (.into db (.-tags db))
     (drift/TagsCompanion.insert
      .id id
      .name name))))

(defn get-tag-by-id [id]
  (let [^drift/AppDatabase db @db]
    (.getSingleOrNull
     (doto (.select db (.-tags db))
       (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id)))))))

(defn get-tag-by-name [name]
  (let [^drift/AppDatabase db @db]
    (.getSingleOrNull
     (doto (.select db (.-tags db))
       (.where (fn [^drift/Tags tbl] (.equals (.-name tbl) name)))))))

(defn get-all-tags []
  (let [^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-tags db))
       (.orderBy [(fn [^drift/Tags tbl] (d/OrderingTerm. .expression (.-name tbl) .mode d/OrderingMode.asc))])))))

(defn get-tags-paginated [page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-tags db))
       (.orderBy [(fn [^drift/Tags tbl] (d/OrderingTerm. .expression (.-name tbl) .mode d/OrderingMode.asc))])
       (.limit limit .offset offset)))))

(defn update-tag [id name]
  (let [^drift/AppDatabase db @db
        query (doto (.update db (.-tags db))
                (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id))))
        companion (drift/TagsCompanion.
                   .name name)]
    (.write query companion)))

(defn delete-tag [id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-tags db))
       (.where (fn [^drift/Tags tbl]
                 (.equals (.-id tbl) id)))))))

(defn search-tags [query page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect db 
                    " SELECT * FROM TAGS 
                     WHERE NAME LIKE ?
                     ORDER BY NAME ASC 
                     LIMIT ? OFFSET ?"
                    .variables [(d/Variable query) (d/Variable limit) (d/Variable offset)]))))

(defn get-tags-count []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    " SELECT COUNT (*) as count FROM tags "))))

;; ===== NoteTags db functions =====

(defn add-tag-to-note [note-id tag-id]
  (let [^drift/AppDatabase db @db]
    (.insert
     (.into db (.-noteTags db))
     (drift/NoteTagsCompanion.insert
      .noteId note-id
      .tagId tag-id))))

(defn remove-tag-from-note [note-id tag-id]
  (let [^drift/AppDatabase db @db]
    (.go
     (doto
      (.delete db (.-noteTags db))
       (.where (fn [^drift/NoteTags tbl]
                 (and
                  (.equals (.-noteId tbl) note-id)
                  (.equals (.-tagId tbl) tag-id))))))))

(defn get-note-tags [note-id]
  (let [^drift/AppDatabase db @db]
     (.get
      (.customSelect
       db
       " SELECT t.* FROM tags t
         INNER JOIN note_tags nt ON t.id = nt.tag_id
         WHERE nt.note_id = ?
         ORDER BY t.name ASC "
       .variables
       [(d/Variable note-id)]))))

(defn get-tagged-notes [tag-id page limit]
  (let [offset (* page limit)
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect db
                    " SELECT n.*, nfts.content as content FROM notes n
                      LEFT JOIN note_fts nfts ON n.id = nfts.id
                      INNER JOIN note_tags nt ON n.id = nt.note_id
                      WHERE nt.tag_id = ? AND n.is_deleted = false
                      ORDER BY n.updated_at DESC
                      LIMIT ? OFFSET ? "
                    .variables
                    [(d/Variable tag-id) (d/Variable limit) (d/Variable offset)]))))

(defn get-notes-by-tags [tag-ids page limit]
  (let [offset (* page limit)
        placeholders (clojure.string/join "," (repeat (count tag-ids) " ? "))
        ^drift/AppDatabase db @db]
    (.get
     (.customSelect db
                    (str " SELECT n.*, nfts.content as content FROM notes n
                           LEFT JOIN note_fts nfts ON n.id = nfts.id
                           INNER JOIN note_tags nt ON n.id = nt.note_id
                           WHERE nt.tag_id IN (" placeholders ") AND n.is_deleted = false
                           GROUP BY n.id
                           HAVING COUNT (DISTINCT nt.tag_id) = ?
                           ORDER BY n.updated_at DESC
                           LIMIT ? OFFSET ? ")
                    .variables
                    (concat (map d/Variable tag-ids) [(d/Variable (count tag-ids)) (d/Variable limit) (d/Variable offset)])))))

(defn get-tagged-notes-count [tag-id]
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    " SELECT COUNT (*) as count FROM note_tags nt
                      INNER JOIN notes n ON nt.note_id = n.id
                      WHERE nt.tag_id = ? AND n.is_deleted = false "
                    .variables [(d/Variable tag-id)]))))

(defn delete-note-with-blocks [id]
  (-> (get-blocks-by-note-id id)
      (.then (fn [blocks]
               ;; Step 1: Delete all blocks
               (-> (doseq [block blocks]
                     (delete-block (:id block)))
                   (.then (fn [_]
                            ;; Step 3: Delete note_fts and note
                            (soft-delete-note id))))))))

;; Create note with content (4 steps: note, note_fts, blocks, block_ids)
(defn create-note-with-content [^String content & [id]]
  (let [^String id (or id (.v4 uuid-instance))
        ^drift/AppDatabase db @db
        ^String
        title (string-utils/extract-title-from-content content)]
    (.transaction
     db
     (fn []
       (create-note id title)
       (create-note-content id content)))))

;; Update note with content (4 steps: note, note_fts, blocks, block_ids)
(defn update-note-with-content [^String id ^String title ^String content]
  (dart:core/print (str "update-note-with-content id = " id " title = " title " content = " content))
  (let [^drift/AppDatabase db @db]
    (.transaction
     db
     (fn []
       (update-note id title)
       (update-note-content id content)))))

(defn create-note-from-server [server-note]
  (let [^String id (get server-note "id")
        ^String content (get server-note "content")]
    (create-note-with-content content id)))

(defn update-note-from-server [server-note]
  (let [^String id (get server-note "id")
        ^String title (string-utils/extract-title-from-content (get server-note "content"))
        ^String content (get server-note "content")]
    (update-note-with-content id title content)))

;; Update note sync status
(defn update-note-sync-status [id status & {:keys [synced-at] :or {synced-at nil}}]
  (let [^drift/AppDatabase db @db]
    (if synced-at
      (.customStatement db
                        "UPDATE notes SET sync_status = ?, synced_at = ? WHERE id = ?"
                        [status synced-at id])
      (.customStatement db
                        "UPDATE notes SET sync_status = ?, synced_at = now() WHERE id = ?"
                        [status id]))))

;; Get notes for synchronization
(defn get-notes-for-sync []
  (let [^drift/AppDatabase db @db]
    (.get
     (doto (.select db (.-notes db))
       (.where (fn [^drift/Notes tbl] (.equals (.-syncStatus tbl) "pending")))
       (.orderBy [(fn [^drift/Notes tbl] (d/OrderingTerm. .expression (.-updatedAt tbl) .mode d/OrderingMode.asc))])))))

;; Get pending notes count
(defn get-pending-notes-count []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM notes WHERE sync_status = 'pending'"))))

;; Get synced notes count
(defn get-synced-notes-count []
  (let [^drift/AppDatabase db @db]
    (.getSingle
     (.customSelect db
                    "SELECT COUNT(*) as count FROM notes WHERE sync_status = 'synced'"))))


