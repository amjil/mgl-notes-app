(ns notes-app.widgets.mgl-search-pannel
  (:require
   ["package:flutter/material.dart" :as m]
   ["package:mongol/mongol.dart" :as mgl]
   [clojure.string :as str]
   [notes-app.widgets.mgl-keyboard :as keyboard]
   [notes-app.widgets.mgl-suggestion-panel :as suggestion-panel]
   [notes-app.widgets.mgl-note-item :as note-item]
   [notes-app.widgets.mgl-infinite-scroll :as infinite-scroll]
   [notes-app.widgets.mgl-text-input :as text-input]
   [notes-app.widgets.mgl-empty-state :as empty-state]
   [notes-app.states.ui :as ui]
   [notes-app.states.search :as search-state]
   [cljd.flutter :as f]))

;; ==================== Search specific functions ====================

;; Check if should trigger load more for search results
(defn should-load-more-search? []
  (search-state/has-more?))

;; Load more search results trigger function
(defn load-more-search-trigger [ctx]
  (when (should-load-more-search?)
    (search-state/load-more-search-results! ctx)))

;; Search result item builder
(defn search-result-item-builder [result]
  (note-item/note-item result))

;; Handle search input change
(defn handle-search-change [ctx val]
  ;; Update search query in global state
  (swap! search-state/search-state assoc :search-query val)
  ;; Perform search with pagination
  (when (not (str/blank? val))
    (search-state/search-notes! ctx val 1 20))
  ;; Clear search results if query is empty
  (when (str/blank? val)
    (search-state/clear-search-results!)))

;; Handle search input tap
(defn handle-search-tap []
  (swap! ui/ui-state assoc :keyboard/candidates-list [])
  (dart:core/print "onTap MongolTextField"))

;; ==================== Search result panel widget ====================

;; Search result panel with infinite scroll
(defn search-result-panel []
  (f/widget
   :watch [{search-results :results} search-state/search-state
           {search-query :query} search-state/search-state
           {searching :searching} search-state/search-state
           {loading-more :loading-more} search-state/search-state
           {has-more :has-more} search-state/search-state
           {total-count :total-count} search-state/search-state]
   :managed [scroll-controller (infinite-scroll/create-scroll-controller load-more-search-trigger)]
   (cond
     (str/blank? search-query)
     ;; Initial state, show blank area
     (suggestion-panel/suggestion-panel)

     ;; Already has search content, show list regardless of whether results are empty
     (empty? search-results)
     (empty-state/empty-search-results)

     :else
     (infinite-scroll/infinite-scroll-list
      {:items search-results
       :scroll-controller scroll-controller
       :scroll-direction m/Axis.horizontal
       :item-builder search-result-item-builder
       :loading-more? loading-more
       :has-more? has-more
       :all-loaded? (not has-more)
       :load-more-indicator (infinite-scroll/load-more-indicator infinite-scroll/search-loading-more-text)
       :all-loaded-indicator (infinite-scroll/all-loaded-indicator infinite-scroll/search-all-loaded-text)}))))

;; ==================== Search panel widget ====================

;; Search panel with enhanced functionality
(defn search-panel []
  (f/widget
   :context ctx
   :managed [controller (m/TextEditingController.)]
   (m/SafeArea)
   (m/Stack
    .children
    [(m/Column
      .children
      [(m/Expanded
        .child
        (m/Row
         .crossAxisAlignment m/CrossAxisAlignment.stretch
         .children
         [(text-input/search-text-field controller (partial handle-search-change ctx) handle-search-tap)
          (m/Expanded
           .child (search-result-panel))]))
       (keyboard/keyboard)])
     (keyboard/candidates-panel)]))) 