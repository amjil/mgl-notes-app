(ns notes-app.utils.note
  (:require 
   [clojure.string :as str]
   [clojure.set :as set]
   [virtual-keyboard.keyboard-action :as keyboard-action]
   [block-editor.state :as editor-state]
   [block-editor.utils.block :as editor-util]
   [notes-app.utils.string :as string-utils]
   [notes-app.states.notes :as notes]
   [notes-app.utils.tag :as tags-utils]
   [notes-app.services.db :as db]
   [notes-app.utils.toast :as toast]
   [notes-app.utils.state-helpers :as helpers]
   ["package:uuid/uuid.dart" :as uuid]
   ["dart:async" :as async]))




(defn build-content-from-blocks [ids blocks-map]
  (->> ids
       (map (fn [bid] (get blocks-map bid "")))
       (str/join "\n")))

(defn- to-id-set [coll]
  (set (map (fn [b]
              (or (:id b) (.-id b)))
            coll)))

(defn- to-content-map [coll]
  (into {}
        (map (fn [b]
               (let [bid (or (:id b) (.-id b))
                     content (or (:content b) (.-content b))]
                 [bid content])))
        coll))

(defn- to-meta-map [coll]
  (into {}
        (map (fn [b]
               (let [bid (or (:id b) (.-id b))
                     meta (or (:metaData b) (.-metaData b))]
                 [bid meta])))
        coll))

(defn- json-array-of-strings [xs]
  (str "[" (str/join "," (map (fn [s] (str "\"" s "\"")) xs)) "]"))

(defn- update-note-references!
  "Update note references based on link-ids from editor state"
  [note-id]
  (let [current-link-ids (set (vals @editor-state/link-ids)) 
        existing-refs-promise (db/get-note-reference-ids note-id)]
    (-> existing-refs-promise
        (.then (fn [existing-refs]
                 (let [existing-ids (set existing-refs)
                       to-remove (set/difference existing-ids current-link-ids)
                       to-add (set/difference current-link-ids existing-ids)]
                   ;; Delete removed references
                   (doseq [ref-id to-remove]
                     (db/delete-note-reference note-id ref-id))
                   ;; Add new references
                   (doseq [ref-id to-add]
                     (db/create-note-reference note-id ref-id))))))))

(defn- extract-note-links
  "Extract note link titles from content (format: [[title]])"
  [content]
  (let [links (re-seq #"\[\[([^\]]+)\]\]" content)]
    (->> links
         (map second)
         (map str/trim)
         (filter #(not (str/blank? %)))
         distinct)))

(defn update-note-references-from-content!
  "Update note references based on links extracted from content"
  [note-id content]
  (let [current-link-titles (set (extract-note-links content))
        existing-refs-promise (db/get-note-references note-id)]
    (-> existing-refs-promise
        (.then (fn [existing-refs]
                 (let [existing-refs (map #(.-data %) existing-refs)
                       existing-title-to-id (into {}
                                                  (map (fn [ref]
                                                         (let [ref-id (or (get ref "id")
                                                                         (get ref :id)
                                                                         (.-id ref))
                                                               ref-title (or (get ref "title")
                                                                            (get ref :title)
                                                                            (.-title ref))]
                                                           [ref-title ref-id]))
                                                       existing-refs))
                       existing-titles (set (keys existing-title-to-id))
                       to-remove-titles (set/difference existing-titles current-link-titles)
                       to-add-titles (set/difference current-link-titles existing-titles)]
                   ;; Delete removed references
                   (doseq [title to-remove-titles]
                     (let [ref-id (get existing-title-to-id title)]
                       (when ref-id
                         (db/delete-note-reference note-id ref-id))))
                   ;; Add new references by looking up notes by title
                   (doseq [title to-add-titles]
                     (-> (db/get-note-by-title title)
                         (.then (fn [note]
                                  (if note
                                    (let [note-data (.-data note)
                                          ref-id (or (get note-data "id")
                                                     (get note-data :id)
                                                     (.-id note-data))]
                                      (db/create-note-reference note-id ref-id))
                                    nil)))))))))))

(defn- update-note-tags!
  "Update note tags based on tags extracted from content"
  [note-id content]
  (let [current-tag-names (set (tags-utils/extract-tags content))
        existing-tags-promise (db/get-note-tags note-id)]
    (-> existing-tags-promise
        (.then (fn [existing-tags]
                 (let [existing-tags (map #(.-data %) existing-tags)
                       existing-tag-names (set (map (fn [tag]
                                                      (or (get tag "name")
                                                          (get tag :name)
                                                          (.-name tag)))
                                                    existing-tags))
                       existing-tag-ids (into {}
                                              (map (fn [tag]
                                                     (let [tag-name (or (get tag "name")
                                                                        (get tag :name)
                                                                        (.-name tag))
                                                           tag-id (or (get tag "id")
                                                                      (get tag :id)
                                                                      (.-id tag))]
                                                       [tag-name tag-id]))
                                                   existing-tags))
                       to-remove-names (set/difference existing-tag-names current-tag-names)
                       to-add-names (set/difference current-tag-names existing-tag-names)]
                   ;; Delete removed tags
                   (doseq [tag-name to-remove-names]
                     (let [tag-id (get existing-tag-ids tag-name)]
                       (when tag-id
                         (db/remove-tag-from-note note-id tag-id))))
                   ;; Add new tags
                   (doseq [tag-name to-add-names]
                     (-> (db/get-tag-by-name tag-name)
                         (.then (fn [tag]
                                  (if tag
                                    ;; Tag exists, use its id
                                    (let [tag (.-data tag)
                                          tag-id (or (get tag "id")
                                                     (get tag :id)
                                                     (.-id tag))]
                                      (db/add-tag-to-note note-id tag-id))
                                    ;; Tag doesn't exist, create it first
                                    (let [^uuid/Uuid uuid-instance (uuid/Uuid.)
                                          new-id (.v4 uuid-instance)]
                                      (-> (db/create-tag tag-name new-id)
                                          (.then (fn [_]
                                                   (db/add-tag-to-note note-id new-id))))))))))))))))

(defn save-blocks-for-note! [_ctx note-id]
  (let [ids @editor-state/ids
        ;; The first block is used as the note title and is not stored in the blocks table
        body-ids (vec (rest ids))
        blocks-map @editor-state/blocks
        blocks-meta @editor-state/block-meta
        levels @editor-state/levels
        block-content-with-indent (fn [bid]
                                    (let [level (or (get levels bid) 0)
                                          content (str (get blocks-map bid ""))]
                                      (str (apply str (repeat level "\t")) content)))]
    (-> (db/get-blocks-by-note-id note-id)
        (.then (fn [existing]
                 (let [existing-ids (to-id-set existing)
                       existing-content (to-content-map existing)
                       existing-meta (to-meta-map existing)
                       current-ids (set body-ids)
                       ;; Diff sets between editor state and database
                       to-create (remove existing-ids body-ids)
                       to-delete (remove current-ids existing-ids)
                       to-update (filter (fn [bid]
                                           (let [old (get existing-content bid)
                                                 now (block-content-with-indent bid)
                                                 old-meta (get existing-meta bid)
                                                 meta (get blocks-meta bid)]
                                             (or (not= (str old) (str now))
                                                 (not= (str old-meta) (string-utils/json-encode meta)))))
                                         (filter existing-ids body-ids))]
                   ;; Create blocks using editor blockId as DB primary key to keep FTS and blockIds consistent
                   (doseq [bid to-create]
                     (let [content (block-content-with-indent bid)
                           block-meta (string-utils/json-encode (get blocks-meta bid))]
                       (db/create-block note-id content bid block-meta)
                       (db/update-block-content bid content)))
                   ;; Update existing blocks
                   (doseq [bid to-update]
                     (let [content (block-content-with-indent bid)
                           block-meta (string-utils/json-encode (get blocks-meta bid))]
                       (db/update-block bid content block-meta)
                       (db/update-block-content bid content)))
                   ;; Delete removed blocks
                   (doseq [bid to-delete]
                     (db/delete-block bid))
                   ;; Update note.blockIds with editor order
                   (db/update-note-block-ids note-id (json-array-of-strings body-ids))))))))
                   
(declare clear-note-editor)

(defn load-note-to-editor! []
  (let [current (notes/get-current-note)]
    (if (nil? current)
      (editor-util/clean)
      (let [note-id (get current "id")
            note-title (get current "title" "")]
        (-> (db/get-blocks-by-note-id note-id)
            (.then (fn [blocks]
                     (editor-util/clean)
                     (let [^uuid/Uuid uuid-instance (uuid/Uuid.)
                           title-id (.v4 uuid-instance)
                           meta-data (get current "metaData")
                           title-meta (if (nil? meta-data) {} (string-utils/json-decode meta-data))
                           parsed (reduce (fn [{:keys [block-ids blocks-map levels-map block-meta]} b]
                                            (let [bid (or (:id b) (.-id b))
                                                  raw-content (str (or (:content b) (.-content b) ""))
                                                  leading-tabs (count (re-find #"^\t*" raw-content))
                                                  content-without-tabs (subs raw-content leading-tabs)
                                                  trimmed-content (str/trim content-without-tabs)
                                                  meta-data (or (:metaData b) (.-metaData b))
                                                  meta (if (nil? meta-data) {} (into {} (string-utils/json-decode meta-data)))]
                                              {:block-ids (conj block-ids bid)
                                               :blocks-map (assoc blocks-map bid trimmed-content)
                                               :levels-map (assoc levels-map bid leading-tabs)
                                               :block-meta (assoc block-meta bid meta)}))
                                          {:block-ids [] :blocks-map {} :levels-map {} :block-meta {}}
                                          blocks)
                           block-ids (:block-ids parsed)
                           blocks-map (:blocks-map parsed)
                           levels-map (:levels-map parsed)
                           block-meta (:block-meta parsed)
                           ;; Create IDs list with title as first block
                           all-ids (vec (cons title-id block-ids))
                           ;; Create blocks map with title as first block
                           all-blocks-map (assoc blocks-map title-id (str/trim (or note-title "")))
                           ;; Create levels map with title level set to 0
                           all-levels-map (assoc levels-map title-id 0)
                           ;; Create block meta map with title as first block
                           all-block-meta (assoc block-meta title-id title-meta)]
                       (dart:core/print (str "block-meta = " all-block-meta))
                       ;; Set editor state
                       (reset! editor-state/ids all-ids)
                       (reset! editor-state/blocks all-blocks-map)
                       (reset! editor-state/levels all-levels-map)
                       (reset! editor-state/block-meta all-block-meta)
                       ;; Build content from blocks to check for note links
                       (let [content (build-content-from-blocks all-ids all-blocks-map)]
                         ;; Load note references and update link-ids
                         ;; Update note references based on content
                         (update-note-references-from-content! note-id content)
                         ;; link-ids is a map with title as key and id as value
                         (-> (db/get-note-references note-id)
                             (.then (fn [refs]
                                      (let [refs (map #(.-data %) refs)
                                            link-ids-map (into {}
                                                               (map (fn [ref]
                                                                      (let [ref-id (or (get ref "id")
                                                                                       (get ref :id)
                                                                                       (.-id ref))
                                                                            ref-title (or (get ref "title")
                                                                                          (get ref :title)
                                                                                          (.-title ref))]
                                                                        [ref-title ref-id]))
                                                                    refs))]
                                        (reset! editor-state/link-ids link-ids-map)
                                        nil)))))))))))))

(declare clear-note-editor)

(defn save-or-update-note! [ctx]
  (let [ids @editor-state/ids
        blocks-map @editor-state/blocks
        block-meta @editor-state/block-meta
        content (build-content-from-blocks ids blocks-map)
        trimmed (some-> content str/trim)
        current (notes/get-current-note)
        ^uuid/Uuid uuid-instance (uuid/Uuid.)
        title-id (first ids)
        title-meta-raw (get block-meta title-id)
        title-meta (string-utils/json-encode title-meta-raw)]
    (keyboard-action/clear-candidates)
    (if (or (nil? trimmed) (empty? trimmed))
      (do
        (toast/show-toast ctx "Please enter a note")
        (async/Future.value false))
      (if (nil? current)
        (let [new-id (.v4 uuid-instance)]
          (-> (db/create-note-with-content content new-id title-meta)
              (.then (fn [_]
                       (save-blocks-for-note! ctx new-id)
                       (update-note-references! new-id)
                       (update-note-tags! new-id content)
                       ;; Reload notes list after creating note
                       (notes/load-notes-paginated! ctx 0)
                       (async/Future.value true)))))
        (let [note-id (get current "id")
              title (string-utils/extract-title-from-content content)]
          (-> (db/update-note-with-content note-id title content title-meta)
              (.then (fn [_]
                       (save-blocks-for-note! ctx note-id)
                       (update-note-references! note-id)
                       (update-note-tags! note-id content)
                       ;; Reload notes list after creating note
                       (notes/load-notes-paginated! ctx 0)
                       (async/Future.value true)))))))))

(defn clear-note-editor []
  (notes/set-current-note! nil)
  (editor-util/clean))

(defn favorite [id]
  (->
   (db/add-favorite-note id)
   (.then (fn [x]
            (-> (db/get-notes-paginated 0 20)
                (.then (fn [notes]
                         (helpers/handle-pagination-result! notes/notes-state 0 notes 20))))))))

(defn unfavorite [id]
  (->
   (db/remove-favorite-note id)
   (.then (fn [x]
            (-> (db/get-notes-paginated 0 20)
                (.then (fn [notes]
                         (helpers/handle-pagination-result! notes/notes-state 0 notes 20))))))))